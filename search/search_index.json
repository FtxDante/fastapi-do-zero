{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"[WIP] FastAPI do ZERO","text":""},{"location":"#wip-fastapi-do-zero","title":"[WIP] FastAPI do ZERO","text":"<p>Ainda est\u00e1 em uma fase bastante embrion\u00e1ria esse arquivo!</p>"},{"location":"#criando-um-projeto-com-bancos-de-dados-testes-e-deploy","title":"Criando um Projeto com Bancos de Dados, Testes e Deploy","text":"<p>Ol\u00e1 a todos e boas vindas ao curso \"FastAPI do Zero: Criando um Projeto com Bancos de Dados, Testes e Deploy\". Nessa aula vamos abordar o que voc\u00ea pode esperar aprender neste curso e como ele est\u00e1 estruturado. Ent\u00e3o, sem mais delongas, vamos come\u00e7ar!</p>"},{"location":"#o-que-e-fastapi","title":"O que \u00e9 FastAPI?","text":"<p>FastAPI \u00e9 um framework Python moderno e r\u00e1pido (alta performance) para constru\u00e7\u00e3o de APIs, que \u00e9 f\u00e1cil de aprender e traz in\u00fameros benef\u00edcios. FastAPI aproveita as anota\u00e7\u00f5es de tipo Python para fornecer uma experi\u00eancia incrivelmente eficiente para desenvolver APIs RESTful.</p>"},{"location":"#sobre-o-curso","title":"Sobre o curso","text":"<p>Este curso foi criado com um prop\u00f3sito em mente: ajudar desenvolvedores, tanto iniciantes quanto experientes, a entender e utilizar o FastAPI para construir APIs. Durante as aulas, construiremos um projeto pr\u00e1tico de gerenciamento de tarefas (um todo list), com autentica\u00e7\u00e3o de usu\u00e1rios e todas as opera\u00e7\u00f5es CRUD (criar, ler, atualizar, deletar).</p>"},{"location":"#o-que-voce-vai-aprender","title":"O que voc\u00ea vai aprender?","text":""},{"location":"#ao-longo-deste-curso-vamos-cobrir-os-seguintes-topicos","title":"Ao longo deste curso, vamos cobrir os seguintes t\u00f3picos:","text":"<ol> <li> <p>Configura um ambiente de desenvolvimento para FastAPI: Para garantir que todos est\u00e3o na mesma p\u00e1gina, come\u00e7aremos do zero, configurando nosso ambiente de desenvolvimento.</p> </li> <li> <p>Primeiros Passos com FastAPI e TDD: Ap\u00f3s a configura\u00e7\u00e3o do ambiente, come\u00e7aremos a explorar a estrutura b\u00e1sica de um projeto FastAPI, juntamente com uma introdu\u00e7\u00e3o ao Desenvolvimento Orientado a Testes (TDD).</p> </li> <li> <p>Modelagem de Dados com Pydantic e SQLAlchemy: Abordaremos como criar e manipular modelos de dados com Pydantic e SQLAlchemy, duas bibliotecas poderosas que tornam o FastAPI ainda mais eficaz.</p> </li> <li> <p>Autentica\u00e7\u00e3o e Autoriza\u00e7\u00e3o em FastAPI: Ensinar-lhe-emos a construir um sistema de autentica\u00e7\u00e3o para proteger suas rotas e garantir que apenas usu\u00e1rios autenticados possam acessar dados espec\u00edficos.</p> </li> <li> <p>Testando sua Aplica\u00e7\u00e3o FastAPI: Uma introdu\u00e7\u00e3o completa ao teste de sua aplica\u00e7\u00e3o FastAPI com o pytest e coverage.</p> </li> <li> <p>Dockerizando e Fazendo Deploy de sua Aplica\u00e7\u00e3o FastAPI: Por fim, vamos cobrir como dockerizar sua aplica\u00e7\u00e3o FastAPI e como fazer o deploy dela usando Fly.io.</p> </li> </ol>"},{"location":"#pre-requisitos","title":"Pr\u00e9-requisitos","text":"<p>Para aproveitar ao m\u00e1ximo este curso, \u00e9 recomendado que voc\u00ea tenha algum conhecimento pr\u00e9vio de Python. Al\u00e9m disso, algum entendimento b\u00e1sico de desenvolvimento web e APIs RESTful ser\u00e1 \u00fatil, mas n\u00e3o essencial, pois abordaremos esses t\u00f3picos durante o curso.</p> <p>Adicionar aqui link para o curso introdut\u00f3rio de python</p>"},{"location":"#aulas","title":"Aulas","text":"<ol> <li>Configurando o Ambiente de Desenvolvimento</li> <li>Estruturando seu Projeto e Criando Rotas CRUD</li> <li>Configurando Banco de Dados e Gerenciando Migra\u00e7\u00f5es com Alembic</li> <li>Integrando Banco de Dados a API</li> <li>Autentica\u00e7\u00e3o e Autoriza\u00e7\u00e3o</li> <li>Refatorando a Estrutura do Projeto</li> <li>...</li> </ol>"},{"location":"#conclusao","title":"Conclus\u00e3o","text":"<p>Estamos muito animados para come\u00e7ar esta jornada com voc\u00ea. Se voc\u00ea est\u00e1 pronto para aprender como construir APIs web eficientes e robustas com FastAPI, ent\u00e3o este \u00e9 o curso certo para voc\u00ea. Fique atento para a pr\u00f3xima aula, onde vamos configurar nosso ambiente de desenvolvimento e dar os primeiros passos com FastAPI e TDD!</p>"},{"location":"01/","title":"[OK] Configurando o Ambiente de Desenvolvimento","text":""},{"location":"01/#ok-configurando-o-ambiente-de-desenvolvimento","title":"[OK] Configurando o Ambiente de Desenvolvimento","text":"<p>Objetivos dessa aula:</p> <ul> <li>Introdu\u00e7\u00e3o ao ambiente de desenvolvimento (IDE, terminal, etc.)</li> <li>Instala\u00e7\u00e3o do FastAPI e suas depend\u00eancias</li> <li>Configura\u00e7\u00e3o das ferramentas de desenvolvimento</li> <li>Execu\u00e7\u00e3o do primeiro \"Hello, World!\" com FastAPI com testes!</li> </ul> Caso prefira ver a aula em v\u00eddeo <p></p> <p>Aula  Slides  C\u00f3digo </p> <p>Nesta aula pr\u00e1tica, vamos come\u00e7ar nossa jornada na constru\u00e7\u00e3o de uma API com FastAPI. Esse \u00e9 um moderno e r\u00e1pido (altamente perform\u00e1tico) framework web para constru\u00e7\u00e3o de APIs com Python 3.7+ baseado em Python type hints.</p> <p>Partiremos do b\u00e1sico, configurando nosso ambiente de desenvolvimento. Discutiremos desde a escolha e instala\u00e7\u00e3o da vers\u00e3o correta do Python at\u00e9 a instala\u00e7\u00e3o e configura\u00e7\u00e3o do Poetry, um gerenciador de pacotes e depend\u00eancias para Python. Al\u00e9m disso, instalaremos e configuraremos uma s\u00e9rie de ferramentas de desenvolvimento \u00fateis, como Ruff, Blue, Isort, pytest e Taskipy.</p> <p>Depois de configurado o nosso ambiente, criaremos nosso primeiro programa \"Hello, World!\" com FastAPI. Isso nos permitir\u00e1 confirmar que tudo est\u00e1 funcionando corretamente. E, finalmente, exploraremos uma parte crucial do Desenvolvimento Orientado por Testes (TDD), escrevendo nosso primeiro teste com Pytest.</p>"},{"location":"01/#ambiente-de-desenvolvimento","title":"Ambiente de Desenvolvimento","text":"<p>Para iniciar essa aula voc\u00ea vai precisar de algumas ferramentas.</p> <ol> <li>Um editor de texto a sua escolha (Eu vou usar o GNU/Emacs)</li> <li>Um terminal a sua escolha (Usarei o Terminator)</li> <li>A vers\u00e3o 3.11 do Python instalada.<ul> <li>Caso n\u00e3o tenha essa vers\u00e3o voc\u00ea pode baixar do site oficial</li> <li>Ou instalar via pyenv</li> </ul> </li> <li>O Poetry para gerenciar os pacotes e seu ambiente virtual</li> <li>OPCIONAL: O pipx pode te ajudar bastante nesses momentos</li> <li>Docker</li> </ol>"},{"location":"01/#instalacao-do-python-311","title":"Instala\u00e7\u00e3o do Python 3.11","text":"<p>Se voc\u00ea precisar reconstruir o ambiente usado nesse curso, \u00e9 recomendado que voc\u00ea use o pyenv.</p> <p>Caso tenha problemas durante a instala\u00e7\u00e3o. O pyenv conta com dois assistentes simplificados para sua configura\u00e7\u00e3o. Para windows, use o pyenv-windows. Para GNU/Linux e MacOS, use o pyenv-installer.</p> <p>Navegue at\u00e9 o diret\u00f3rio onde far\u00e1 os exerc\u00edcios e executar\u00e1 os c\u00f3digos de exemplo no seu terminal e digite os seguintes comandos:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>pyenv update\npyenv install 3.11:latest\npyenv local 3.11.3  # Essa era a maior vers\u00e3o do 3.11 quando escrevi\n</code></pre> <p>Certifique que o python rodando no seu ambiente \u00e9 mesmo o 3.11:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>python --version\n</code></pre> <p>A resposta esperada \u00e9 <code>Python 3.11.3</code>.</p>"},{"location":"01/#gerenciamento-de-dependencias-com-poetry","title":"Gerenciamento de Depend\u00eancias com Poetry","text":"<p>Ap\u00f3s instalar o Python, o pr\u00f3ximo passo \u00e9 instalar o Poetry, um gerenciador de pacotes e depend\u00eancias para Python. O Poetry facilita a cria\u00e7\u00e3o, o gerenciamento e a distribui\u00e7\u00e3o de pacotes Python.</p> <p>Para instalar o Poetry, voc\u00ea pode seguir as instru\u00e7\u00f5es presentes na documenta\u00e7\u00e3o oficial do Poetry para o seu sistema operacional. Alternativamente, se voc\u00ea optou por usar o pipx, pode instalar o Poetry com o seguinte comando:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>pipx install poetry\n</code></pre>"},{"location":"01/#criacao-do-projeto-fastapi-e-instalacao-das-dependencias","title":"Cria\u00e7\u00e3o do Projeto FastAPI e Instala\u00e7\u00e3o das Depend\u00eancias","text":"<p>Agora que temos o Python e o Poetry prontos, podemos come\u00e7ar a criar nosso projeto FastAPI.</p> <p>Vamos inicialmente criar um novo diret\u00f3rio para nosso projeto e navegar para ele:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry new fast_zero\ncd fast_zero\n</code></pre> <p>Ele criar\u00e1 uma estrutura como essa:</p> <pre><code>.\n\u251c\u2500\u2500 fast_zero\n\u2502  \u2514\u2500\u2500 __init__.py\n\u251c\u2500\u2500 poetry.lock\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 README.md\n\u2514\u2500\u2500 tests\n   \u2514\u2500\u2500 __init__.py\n</code></pre> <p>Em seguida, inicializaremos um novo projeto Python com Poetry e instalaremos as depend\u00eancias necess\u00e1rias - FastAPI e Uvicorn:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry install\npoetry add fastapi uvicorn\n</code></pre>"},{"location":"01/#primeira-execucao-de-um-hello-world","title":"Primeira Execu\u00e7\u00e3o de um \"Hello, World!\"","text":"<p>Para garantir que tudo est\u00e1 configurado corretamente, vamos criar um pequeno programa \"Hello, World!\" com FastAPI. Em um novo arquivo chamado <code>main.py</code>, adicione o seguinte c\u00f3digo:</p> fast_zero/app.py<pre><code>from fastapi import FastAPI\napp = FastAPI()\n@app.get('/')\ndef read_root():\nreturn {'message': 'Ol\u00e1 Mundo!'}\n</code></pre> <p>Agora, podemos iniciar nosso servidor FastAPI com o seguinte comando:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry shell  # Para ativar o ambiente virtual\nuvicorn fast_zero.app:app --reload\n</code></pre> <p>Acesse http://localhost:8000 no seu navegador, e voc\u00ea deve ver a mensagem \"Hello, World!\" em formato JSON.</p> <p></p>"},{"location":"01/#instalando-as-ferramentas-de-desenvolvimento","title":"Instalando as ferramentas de desenvolvimento","text":"<p>As ferramentas de desenvolvimento escolhidas podem variar de acordo com a prefer\u00eancia pessoal. Nesta aula, utilizaremos algumas que s\u00e3o particularmente \u00fateis para demonstrar certos conceitos:</p> <ul> <li>taskipy: Ferramenta para automatizar alguns comandos e simplificar o fluxo</li> <li>ruff: Um linter, para dizer se n\u00e3o estamos fazendo nada esquisito no c\u00f3digo</li> <li>blue: Um formatador de c\u00f3digo bastante amig\u00e1vel</li> <li>isort: Uma ferramenta para ordenar os imports em ordem alfab\u00e9tica</li> <li>pytest: Ferramenta para executar testes</li> </ul> <p>Para instalar as depend\u00eancias, podemos usar um grupo do poetry focado nelas, para que n\u00e3o sejam usadas em produ\u00e7\u00e3o:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry add --group dev pytest pytest-cov taskipy blue ruff httpx\n</code></pre> <p>O <code>HTTPX</code> foi inclu\u00eddo pois ele \u00e9 uma depend\u00eancia do cliente de testes do FastAPI.</p>"},{"location":"01/#configurando-as-ferramentas-de-desenvolvimento","title":"Configurando as ferramentas de desenvolvimento","text":"<p>Ap\u00f3s a instala\u00e7\u00e3o das depend\u00eancias, vamos precisar configurar todas as ferramentas de desenvolvimento no arquivo <code>pyproject.toml</code>.</p>"},{"location":"01/#ruff","title":"Ruff","text":"<p>Vamos usar o ruff na configura\u00e7\u00e3o padr\u00e3o. As \u00fanicas altera\u00e7\u00f5es que faremos ser\u00e3o para que ele siga a PEP-8, usando 80 caracteres por linha e ignorando o ambiente virtual e pasta de migra\u00e7\u00f5es do banco de dados:</p> pyproject.toml<pre><code>[tool.ruff]\nline-length = 79\nexclude = ['.venv', 'migrations']\n</code></pre>"},{"location":"01/#isort","title":"isort","text":"<p>Vamos configurar o isort para o formato do Black, que coloca um import por linha para evitar conflitos no git e tamb\u00e9m usar a base da PEP-8 para 80 caracteres:</p> pyproject.toml<pre><code>[tool.isort]\nprofile = \"black\"\nline_length = 79\n</code></pre>"},{"location":"01/#pytest","title":"pytest","text":"<p>Configuraremos o pytest para reconhecer o caminho base para execu\u00e7\u00e3o dos testes na raiz do projeto <code>.</code>:</p> pyproject.toml<pre><code>[tool.pytest.ini_options]\npythonpath = \".\"\n</code></pre>"},{"location":"01/#blue","title":"blue","text":"<p>Configuraremos o blue para excluir o caminho das migra\u00e7\u00f5es quando essas forem utilizadas:</p> pyproject.toml<pre><code>[tool.blue]\nextend-exclude = '(migrations/)'\n</code></pre>"},{"location":"01/#taskipy","title":"Taskipy","text":"<p>Para simplificar a execu\u00e7\u00e3o de certos comandos, vamos criar algumas tarefas com o Taskipy.</p> pyproject.toml<pre><code>[tool.taskipy.tasks]\nlint = 'ruff . &amp;&amp; blue --check . --diff'\nformat = 'blue .  &amp;&amp; isort .'\nrun = 'uvicorn fast_zero.app:app --reload'\npre_test = 'task lint'\ntest = 'pytest -s -x --cov=fast_zero -vv'\npost_test = 'coverage html'\n</code></pre> <p>Os comandos definidos fazem o seguinte:</p> <ul> <li>lint: executa o ruff para ver se n\u00e3o temos nenhum problema com o c\u00f3digo e checa se estamos de acordo com a PEP-8</li> <li>format: formata o c\u00f3digo usando blue e isort</li> <li>run: executa o servidor de desenvolvimento do FastAPI</li> <li>pre_test: executa a camada de lint antes de executar os teste</li> <li>test: executa os testes com pytest de forma verbosa (-vv) e adiciona nosso c\u00f3digo como base de cobertura</li> <li>post_test: gera um report de cobertura ap\u00f3s os testes</li> </ul> <p>Para executar um comando, \u00e9 bem mais simples, precisando somente passar a palavra <code>task &lt;comando&gt;</code>.</p> Caso precise do arquivo todo <p>O meu est\u00e1 exatamente assim:</p> pyproject.toml<pre><code>[tool.poetry]\nname = \"fast-zero\"\nversion = \"0.1.0\"\ndescription = \"\"\nauthors = [\"dunossauro &lt;mendesxeduardo@gmail.com&gt;\"]\nreadme = \"README.md\"\npackages = [{include = \"fast_zero\"}]\n[tool.poetry.dependencies]\npython = \"^3.11\"\nfastapi = \"^0.100.0\"\nuvicorn = \"^0.22.0\"\n[tool.poetry.group.dev.dependencies]\npytest = \"^7.4.0\"\npytest-cov = \"^4.1.0\"\ntaskipy = \"^1.11.0\"\nblue = \"^0.9.1\"\nruff = \"^0.0.278\"\nhttpx = \"^0.24.1\"\n[tool.ruff]\nline-length = 79\nexclude = ['.venv', 'migrations']\n[tool.isort]\nprofile = \"black\"\nline_length = 79\n[tool.pytest.ini_options]\npythonpath = \".\"\n[tool.blue]\nextend-exclude = '(migrations/)'\n[tool.taskipy.tasks]\nlint = 'ruff . &amp;&amp; blue --check . --diff'\nformat = 'blue .  &amp;&amp; isort .'\nrun = 'uvicorn fast_zero.app:app --reload'\npre_test = 'task lint'\ntest = 'pytest -s -x --cov=fast_zero -vv'\npost_test = 'coverage html'\n[build-system]\nrequires = [\"poetry-core\"]\nbuild-backend = \"poetry.core.masonry.api\"\n</code></pre>"},{"location":"01/#os-efeitos-dessas-configuracoes-de-desenvolvimento","title":"Os efeitos dessas configura\u00e7\u00f5es de desenvolvimento","text":"<p>Caso voc\u00ea tenha copiado o c\u00f3digo que usamos para definir <code>fast_zero/app.py</code>, pode testar os comandos que criamos para o <code>taskipy</code>:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task lint\n</code></pre> <p>Dessa forma, veremos que cometemos algumas infra\u00e7\u00f5es na formata\u00e7\u00e3o da PEP-8. O blue nos informar\u00e1 que dever\u00edamos ter adicionado duas linhas antes de uma defini\u00e7\u00e3o de fun\u00e7\u00e3o:</p> <pre><code>task lint\n--- fast_zero/app.py    2023-07-12 21:40:14.590616 +0000\n+++ fast_zero/app.py    2023-07-12 21:48:17.017190 +0000\n@@ -1,7 +1,8 @@\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n+\n@app.get('/')\n def read_root():\n     return {'message': 'Ol\u00e1 Mundo!'}\nwould reformat fast_zero/app.py\n\nOh no! \ud83d\udca5 \ud83d\udc94 \ud83d\udca5\n1 file would be reformatted, 2 files would be left unchanged.\n</code></pre> <p>Para corrigir isso, podemos usar o nosso comando de formata\u00e7\u00e3o de c\u00f3digo:</p> ComandoResultado $ Execu\u00e7\u00e3o no terminal!<pre><code>task format\nreformatted fast_zero/app.py\n\nAll done! \u2728 \ud83c\udf70 \u2728\n1 file reformatted, 2 files left unchanged.\nSkipped 2 files\n</code></pre> fast_zero/app.py<pre><code>from fastapi import FastAPI\napp = FastAPI()\n@app.get('/')\ndef read_root():\nreturn {'message': 'Ol\u00e1 Mundo!'}\n</code></pre>"},{"location":"01/#introducao-ao-pytest-testando-o-hello-world","title":"Introdu\u00e7\u00e3o ao Pytest: Testando o \"Hello, World!\"","text":"<p>Antes de entendermos a din\u00e2mica dos testes, precisamos entender o efeito que eles tem no nosso c\u00f3digo. Um bom lugar para come\u00e7ar isso \u00e9 analisando a cobertura. Vamos executar os testes.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n</code></pre> <p>Teremos uma resposta como essa:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>All done! \u2728 \ud83c\udf70 \u2728\n3 files would be left unchanged.\n=========================== test session starts ===========================\nplatform linux -- Python 3.11.3, pytest-7.4.0, pluggy-1.2.\ncachedir: .pytest_cache\nrootdir: /home/dunossauro/git/fast_zero\nconfigfile: pyproject.toml\nplugins: cov-4.1.0, anyio-3.7.1\ncollected 0 items\n\n/&lt;path&gt;/site-packages/coverage/control.py:860:\n  CoverageWarning: No data was collected. (no-data-collected)\nself._warn(\"No data was collected.\", slug=\"no-data-collected\")\n---------- coverage: platform linux, python 3.11.3-final-0 -----------\nName                    Stmts   Miss  Cover\n-------------------------------------------\nfast_zero/__init__.py       0      0   100%\nfast_zero/app.py            5      5     0%\n-------------------------------------------\nTOTAL                       5      5     0%\n</code></pre> <p>As primeiras duas linhas s\u00e3o referentes ao comando do <code>taskipy</code> <code>pre_test</code> que executa o <code>blue</code> e o <code>ruff</code> antes de cada teste. As linhas seguintes s\u00e3o referentes ao pytest, que disse que coletou 0 itens. Nenhum teste foi executado.</p> <p>A parte importante dessa Mensagem est\u00e1 na tabela gerada pelo <code>coverage</code>. Que diz que temos 5 linhas de c\u00f3digo (Stmts) no arquivo <code>fast_zero/app.py</code> e nenhuma delas est\u00e1 coberta pelos nosso testes. Como podemos ver na coluna <code>Miss</code>.</p> <p>Por n\u00e3o ter encontrado nenhum teste, o pytest retornou um \"erro\". Isso significa que nossa tarefa <code>post_test</code> n\u00e3o foi executada. Podemos execut\u00e1-la manualmente:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task post_test\nWrote HTML report to htmlcov/index.html\n</code></pre> <p>Isso gera um relat\u00f3rio de cobertura de testes em formato HTML. Podemos abrir esse arquivo em nosso navegador e entender exatamente quais linhas do c\u00f3digo n\u00e3o est\u00e3o sendo testadas.</p> <p></p> <p>Se clicarmos no arquivo <code>fast_zero/app.py</code> podemos ver em vermelho as linhas que n\u00e3o est\u00e3o sendo testadas</p> <p></p> <p>Isto significa que precisamos testar todo esse arquivo.</p>"},{"location":"01/#escrevendo-o-teste","title":"Escrevendo o teste","text":"<p>Agora, vamos escrever nosso primeiro teste com Pytest.</p> <p>Para testar o fastAPI, precisamos de um cliente de teste. Isso pode ser obtido no m\u00f3dulo <code>fastapi.testclient</code> com o objeto <code>TestClient</code>, que precisa receber nosso app como par\u00e2metro:</p> tests/test_app.py<pre><code>from fastapi.testclient import TestClient\nfrom fast_zero.app import app\nclient = TestClient(app)\n</code></pre> <p>S\u00f3 o fato de termos definido um cliente, j\u00e1 nos mostra uma cobertura bastante diferente:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n# parte da mensagem foi omitida\ncollected 0 items\n\n---------- coverage: platform linux, python 3.11.3-final-0 -----------\nName                    Stmts   Miss  Cover\n-------------------------------------------\nfast_zero/__init__.py       0      0   100%\nfast_zero/app.py            5      1    80%\n-------------------------------------------\nTOTAL                       5      1    80%\n</code></pre> <p>Devido ao fato de n\u00e3o ter coletado nenhum teste, o pytest ainda retornou um \"erro\". Para ver a cobertura, precisaremos executar novamente o <code>post_test</code> manualmente:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task post_test\nWrote HTML report to htmlcov/index.html\n</code></pre> <p>No navegador, podemos ver que a \u00fanica linha n\u00e3o \"testada\" \u00e9 aquela onde temos a l\u00f3gica do endpoint:</p> <p></p> <p>No verde vemos o que foi executado quando chamamos o teste, no vermelho o que n\u00e3o foi.</p> <p>Para resolver isso, temos que criar um teste de fato, fazendo uma chamada para nossa API usando o cliente de teste que definimos:</p> tests/test_app.py<pre><code>from fastapi.testclient import TestClient\nfrom fast_zero.app import app\nclient = TestClient(app)\ndef test_root_deve_retornar_200_e_ola_mundo():\nresponse = client.get('/')\nassert response.status_code == 200\nassert response.json() == {'message': 'Ol\u00e1 Mundo!'}\n</code></pre> <p>Esse teste faz uma requisi\u00e7\u00e3o GET no endpoint <code>/</code> e verifica se o c\u00f3digo de status da resposta \u00e9 200 e se o conte\u00fado da resposta \u00e9 <code>{'message': 'Ol\u00e1 Mundo!'}</code>.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n# parte da mensagem foi omitida\ncollected 1 item\n\ntests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED\n\n---------- coverage: platform linux, python 3.11.3-final-0 -----------\nName                    Stmts   Miss  Cover\n-------------------------------------------\nfast_zero/__init__.py       0      0   100%\nfast_zero/app.py            5      0   100%\n-------------------------------------------\nTOTAL                       5      0   100%\n\n================ 1 passed in 1.39s ================\nWrote HTML report to htmlcov/index.html\n</code></pre> <p>Dessa forma, temos um teste que coletou 1 item (1 teste). Esse teste foi aprovado e a cobertura n\u00e3o deixou de abranger nenhuma linha de c\u00f3digo.</p> <p>Como conseguimos coletar um item, o <code>post_test</code> foi executado e tamb\u00e9m gerou um HTML com a cobertura atualizada.</p> <p></p>"},{"location":"01/#criando-nosso-repositorio-no-git","title":"Criando nosso reposit\u00f3rio no git","text":"<p>Antes de concluirmos a aula, precisamos criar nosso reposit\u00f3rio no git e criar nosso arquivo <code>.gitignore</code>:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>ignr -p python &gt; .gitignore\ngit init .\ngh repo create\n</code></pre>"},{"location":"01/#conclusao","title":"Conclus\u00e3o","text":"<p>Pronto! Agora temos um ambiente de desenvolvimento totalmente configurado para come\u00e7ar a trabalhar com FastAPI e j\u00e1 fizemos nossa primeira imers\u00e3o no Desenvolvimento Orientado por Testes. Na pr\u00f3xima aula, vamos aprofundar na estrutura\u00e7\u00e3o da nossa aplica\u00e7\u00e3o FastAPI. At\u00e9 l\u00e1!</p>"},{"location":"02/","title":"[OK] Estruturando seu Projeto e Criando Rotas CRUD","text":""},{"location":"02/#ok-estruturando-seu-projeto-e-criando-rotas-crud","title":"[OK] Estruturando seu Projeto e Criando Rotas CRUD","text":"<p>Objetivos dessa aula:</p> <ul> <li>Entendimento dos verbos HTTP, JSON e c\u00f3digos de resposta</li> <li>Compreender a estrutura de um projeto FastAPI e como estruturar rotas CRUD (Criar, Ler, Atualizar, Deletar)</li> <li>Aprender sobre a biblioteca Pydantic e sua utilidade na valida\u00e7\u00e3o e serializa\u00e7\u00e3o de dados</li> <li>Implementa\u00e7\u00e3o de rotas CRUD em FastAPI</li> <li>Escrita e execu\u00e7\u00e3o de testes para validar o comportamento das rotas</li> </ul> Caso prefira ver a aula em v\u00eddeo <p></p> <p>Aula  Slides  C\u00f3digo </p> <p>Boas vindas de volta \u00e0 nossa s\u00e9rie de cursos \"FastAPI do Zero: Criando um Projeto com Bancos de Dados, Testes e Deploy\". Hoje, na Aula 3, vamos avan\u00e7ar na estrutura\u00e7\u00e3o do nosso projeto FastAPI e implementar todas as rotas CRUD (Criar, Ler, Atualizar e Deletar) para o nosso recurso de usu\u00e1rio.</p>"},{"location":"02/#o-que-e-uma-api","title":"O que \u00e9 uma API?","text":"<p>Acr\u00f4nimo de Application Programming Interface (Interface de Programa\u00e7\u00e3o de Aplica\u00e7\u00f5es), uma API \u00e9 um conjunto de regras e protocolos que permitem a comunica\u00e7\u00e3o entre diferentes softwares. As APIs servem como uma ponte entre diferentes programas, permitindo que eles se comuniquem e compartilhem informa\u00e7\u00f5es de maneira eficiente e segura.</p> <p>No mundo moderno, as APIs geralmente comunicam usando o formato de dados JSON (JavaScript Object Notation), que \u00e9 uma maneira leve e eficiente de transmitir dados entre a API e o cliente.</p> <p>As APIs s\u00e3o fundamentais no mundo da programa\u00e7\u00e3o moderna, pois permitem a intera\u00e7\u00e3o entre diferentes sistemas, independentemente de como foram projetados ou em que linguagem foram escritos.</p>"},{"location":"02/#o-que-e-http","title":"O que \u00e9 HTTP?","text":"<p>HTTP, ou Hypertext Transfer Protocol (Protocolo de Transfer\u00eancia de Hipertexto), \u00e9 o protocolo fundamental na web para a transfer\u00eancia de dados e comunica\u00e7\u00e3o entre clientes e servidores.</p> <p>No contexto das APIs, o HTTP \u00e9 o protocolo que permite a comunica\u00e7\u00e3o entre o cliente (geralmente o navegador de um usu\u00e1rio, mas pode ser qualquer coisa que saiba como fazer solicita\u00e7\u00f5es HTTP) e o servidor onde a API est\u00e1 hospedada. As informa\u00e7\u00f5es entre o cliente e o servidor s\u00e3o trocadas na forma de JSON, tornando-se uma linguagem universal para a troca de informa\u00e7\u00f5es na web.</p> <p>O HTTP \u00e9 baseado no modelo de requisi\u00e7\u00e3o-resposta: o cliente faz uma requisi\u00e7\u00e3o para o servidor, e o servidor responde a essa requisi\u00e7\u00e3o. Essas requisi\u00e7\u00f5es e respostas s\u00e3o formatadas de acordo com as regras do protocolo HTTP.</p> <p>A seguir, vamos explorar como os verbos HTTP, os c\u00f3digos de resposta e os c\u00f3digos de erro s\u00e3o utilizados para gerenciar a comunica\u00e7\u00e3o entre o cliente e a API.</p>"},{"location":"02/#compreendendo-os-verbos-http-codigos-de-resposta-e-codigos-de-erro","title":"Compreendendo os Verbos HTTP, C\u00f3digos de Resposta e C\u00f3digos de Erro","text":"<p>Quando trabalhamos com APIs REST, o uso apropriado dos verbos HTTP, c\u00f3digos de resposta e c\u00f3digos de erro \u00e9 crucial para criar uma API clara e consistente. </p>"},{"location":"02/#verbos-http","title":"Verbos HTTP","text":"<p>Os verbos HTTP indicam a a\u00e7\u00e3o desejada a ser executada em um determinado recurso. Os verbos mais comuns s\u00e3o:</p> <ul> <li>GET: Recupera recursos. Deve retornar o status HTTP 200 (OK) se bem-sucedido.</li> <li>POST: Cria um novo recurso. Deve retornar o status HTTP 201 (Criado) se bem-sucedido.</li> <li>PUT: Atualiza um recurso existente. Deve retornar o status HTTP 200 (OK) se bem-sucedido.</li> <li>DELETE: Exclui um recurso. Deve retornar o status HTTP 200 (OK) se bem-sucedido.</li> </ul>"},{"location":"02/#codigos-de-resposta-http","title":"C\u00f3digos de Resposta HTTP","text":"<p>Os c\u00f3digos de resposta HTTP informam ao cliente sobre o resultado de sua solicita\u00e7\u00e3o. Aqui est\u00e3o alguns dos c\u00f3digos de resposta mais comuns:</p> <ul> <li>200 OK: A solicita\u00e7\u00e3o foi bem-sucedida. O significado exato depende do m\u00e9todo HTTP utilizado na solicita\u00e7\u00e3o.</li> <li>201 Created: A solicita\u00e7\u00e3o foi bem-sucedida e um novo recurso foi criado como resultado.</li> <li>404 Not Found: O recurso solicitado n\u00e3o p\u00f4de ser encontrado. Este c\u00f3digo \u00e9 frequentemente usado quando o recurso \u00e9 inexistente.</li> </ul>"},{"location":"02/#codigos-de-erro-http","title":"C\u00f3digos de Erro HTTP","text":"<p>Os c\u00f3digos de erro HTTP indicam que houve um problema com a solicita\u00e7\u00e3o. Alguns c\u00f3digos de erro comuns incluem:</p> <ul> <li>400 Bad Request: A solicita\u00e7\u00e3o era inv\u00e1lida ou malformada.</li> <li>401 Unauthorized: A solicita\u00e7\u00e3o requer autentica\u00e7\u00e3o. Se a solicita\u00e7\u00e3o inclu\u00eda credenciais de autentica\u00e7\u00e3o e mesmo assim retornou 401, isso significa que as credenciais n\u00e3o foram aceitas.</li> <li>403 Forbidden: O cliente n\u00e3o tem permiss\u00f5es para acessar o recurso solicitado, apesar de estar autenticado.</li> <li>404 Not Found: O recurso solicitado n\u00e3o existe no servidor.</li> <li>422 Unprocessable Entity: A solicita\u00e7\u00e3o est\u00e1 bem formada, mas os par\u00e2metros sem\u00e2nticos s\u00e3o inv\u00e1lidos ou incompat\u00edveis.</li> <li>500 Internal Server Error: Ocorreu um erro inesperado no servidor.</li> </ul> <p>Ao trabalhar com APIs REST, \u00e9 importante lidar corretamente com esses c\u00f3digos de resposta e erro para proporcionar uma boa experi\u00eancia para os usu\u00e1rios da API.</p>"},{"location":"02/#como-acontece-a-comunicacao-web-entre-cliente-e-servidor","title":"Como acontece a comunica\u00e7\u00e3o web entre cliente e servidor","text":"<p>A comunica\u00e7\u00e3o entre cliente e servidor na web \u00e9 um processo que ocorre em v\u00e1rias etapas e \u00e9 governado por protocolos de comunica\u00e7\u00e3o espec\u00edficos. O protocolo mais comum \u00e9 o HTTP (Hypertext Transfer Protocol). Essa forma de comunica\u00e7\u00e3o \u00e9 geralmente descrita como stateless, o que significa que cada requisi\u00e7\u00e3o \u00e9 processada de forma independente, sem qualquer conhecimento das requisi\u00e7\u00f5es anteriores.</p> <p>A informa\u00e7\u00e3o \u00e9 trocada na forma de mensagens HTTP, que cont\u00eam dados e informa\u00e7\u00f5es sobre como esses dados devem ser processados. Um aspecto fundamental dessa comunica\u00e7\u00e3o \u00e9 a troca de dados na forma de objetos JSON, que s\u00e3o uma maneira eficiente e flex\u00edvel de representar dados estruturados.</p> <pre><code>sequenceDiagram\n    participant Cliente\n    participant Servidor\n    Cliente-&gt;&gt;Servidor: Requisi\u00e7\u00e3o HTTP (GET, POST, PUT, DELETE)\n    Note right of Servidor: Processa a requisi\u00e7\u00e3o\n    Servidor--&gt;&gt;Cliente: Resposta HTTP (C\u00f3digo de Status)\n    Note left of Cliente: Processa a resposta\n    Cliente-&gt;&gt;Servidor: Requisi\u00e7\u00e3o HTTP com JSON (POST, PUT)\n    Note right of Servidor: Processa a requisi\u00e7\u00e3o e o JSON\n    Servidor--&gt;&gt;Cliente: Resposta HTTP com JSON\n    Note left of Cliente: Processa a resposta e o JSON</code></pre> <p>Este diagrama representa a sequ\u00eancia b\u00e1sica de uma comunica\u00e7\u00e3o cliente-servidor usando HTTP e JSON:</p> <ul> <li>O cliente, geralmente um navegador web ou uma aplica\u00e7\u00e3o, faz uma requisi\u00e7\u00e3o HTTP para o servidor. Essa requisi\u00e7\u00e3o pode ser de diferentes tipos, como GET (para recuperar dados), POST ou PUT (para enviar dados), ou DELETE (para excluir dados).</li> <li>O servidor recebe a requisi\u00e7\u00e3o, processa-a e, em seguida, prepara a resposta. A resposta inclui um c\u00f3digo de status que indica se a requisi\u00e7\u00e3o foi bem-sucedida ou n\u00e3o.</li> <li>O cliente recebe a resposta do servidor e processa-a. Se os dados foram solicitados, eles s\u00e3o exibidos ao usu\u00e1rio. Se foi uma opera\u00e7\u00e3o de envio de dados, a resposta do servidor indicar\u00e1 se a opera\u00e7\u00e3o foi bem-sucedida.</li> <li>Para opera\u00e7\u00f5es que envolvem o envio de dados (como POST e PUT), o cliente inclui os dados na forma de um objeto JSON na requisi\u00e7\u00e3o. O JSON \u00e9 um formato de dados leve e f\u00e1cil de usar que permite a representa\u00e7\u00e3o de estruturas de dados complexas.</li> <li>O servidor recebe a requisi\u00e7\u00e3o com os dados JSON, processa a requisi\u00e7\u00e3o e os dados, e envia uma resposta ao cliente. Esta resposta tamb\u00e9m pode incluir dados no formato JSON.</li> <li>Finalmente, o cliente processa a resposta do servidor e quaisquer dados JSON inclu\u00eddos nela.</li> </ul> <p>Essa \u00e9 uma vis\u00e3o geral simplificada do processo. Na pr\u00e1tica, a comunica\u00e7\u00e3o entre cliente e servidor pode envolver muitas outras nuances, como autentica\u00e7\u00e3o, redirecionamento, cookies e muito mais.</p>"},{"location":"02/#pydantic-e-a-validacao-de-dados","title":"Pydantic e a valida\u00e7\u00e3o de dados","text":"<p>Antes de mergulharmos no c\u00f3digo, vamos entender alguns conceitos importantes.</p> <p>O Pydantic \u00e9 uma biblioteca Python que oferece valida\u00e7\u00e3o de dados e configura\u00e7\u00f5es usando anota\u00e7\u00f5es de tipos Python. Ela \u00e9 utilizada extensivamente em FastAPI para lidar com a valida\u00e7\u00e3o e serializa\u00e7\u00e3o/desserializa\u00e7\u00e3o de dados. O Pydantic tem um papel crucial ao trabalhar com JSON, pois permite a valida\u00e7\u00e3o dos dados recebidos neste formato, assim como sua convers\u00e3o para formatos nativos do Python e vice-versa.</p> <p>Esquemas: No contexto da programa\u00e7\u00e3o, um esquema \u00e9 uma representa\u00e7\u00e3o estrutural de um objeto ou entidade. Por exemplo, no nosso caso, um usu\u00e1rio pode ser representado por um esquema que cont\u00e9m campos para nome de usu\u00e1rio, e-mail e senha. Esquemas s\u00e3o \u00fateis porque permitem definir a estrutura de um objeto de uma maneira clara e reutiliz\u00e1vel.</p> <p>Valida\u00e7\u00e3o de dados: Este \u00e9 o processo de verificar se os dados recebidos est\u00e3o em conformidade com as regras e restri\u00e7\u00f5es definidas. Por exemplo, se esperamos que o campo \"email\" contenha um endere\u00e7o de e-mail v\u00e1lido, a valida\u00e7\u00e3o de dados garantir\u00e1 que os dados inseridos nesse campo de fato correspondam a um formato de e-mail v\u00e1lido.</p> <p>Agora, vamos falar sobre a biblioteca Pydantic.</p> <p>O Pydantic \u00e9 uma biblioteca Python que oferece valida\u00e7\u00e3o de dados e configura\u00e7\u00f5es usando anota\u00e7\u00f5es de tipos Python. Ela \u00e9 utilizada extensivamente em FastAPI para lidar com a valida\u00e7\u00e3o e serializa\u00e7\u00e3o/desserializa\u00e7\u00e3o de dados.</p> <p>O uso do Pydantic nos permite definir modelos de dados, ou \"esquemas\", com campos anotados com tipos de dados. O Pydantic garante que as inst\u00e2ncias desses modelos sempre estejam em conformidade com o esquema definido.</p> <p>Vamos considerar um exemplo onde recebemos o seguinte objeto JSON, representando um novo usu\u00e1rio que quer se registrar em nosso servi\u00e7o:</p> <pre><code>{\n\"username\": \"joao123\",\n\"email\": \"joao123@email.com\",\n\"password\": \"segredo123\"\n}\n</code></pre> <p>Para lidar com esta entrada de dados, devemos definir um esquema Pydantic que corresponda \u00e0 estrutura deste objeto JSON. Usamos anota\u00e7\u00f5es de tipos Python para definir o tipo de dado de cada campo:</p> <pre><code>from pydantic import BaseModel, EmailStr\nclass UserSchema(BaseModel):\nusername: str\nemail: EmailStr\npassword: str\n</code></pre> <p>Neste exemplo, o campo <code>username</code> \u00e9 esperado como uma string, o campo <code>email</code> como uma string que valida o formato de um endere\u00e7o de email (gra\u00e7as \u00e0 anota\u00e7\u00e3o <code>EmailStr</code> do Pydantic), e o campo <code>password</code> tamb\u00e9m \u00e9 esperado como uma string.</p> <p>Ao usar este esquema, qualquer tentativa de criar um usu\u00e1rio com dados que n\u00e3o correspondam a este formato (por exemplo, um email que n\u00e3o \u00e9 v\u00e1lido, ou um campo de nome de usu\u00e1rio que n\u00e3o \u00e9 uma string) resultar\u00e1 em um erro de valida\u00e7\u00e3o.</p>"},{"location":"02/#suporte-a-emails","title":"Suporte a emails","text":"<p>Para que o pydantic suporte a valida\u00e7\u00e3o de emails, \u00e9 necess\u00e1rio instalar o <code>pydantic[email]</code></p> <p>Ademais, se tentarmos criar um usu\u00e1rio com um email inv\u00e1lido, o Pydantic ir\u00e1 automaticamente validar o campo e retornar um erro \u00fatil. Isso nos poupa muito trabalho de valida\u00e7\u00e3o manual e ajuda a manter nossa API robusta e confi\u00e1vel.</p>"},{"location":"02/#implementando-as-rotas-crud","title":"Implementando as Rotas CRUD","text":"<p>CRUD \u00e9 um acr\u00f4nimo que representa as quatro opera\u00e7\u00f5es b\u00e1sicas que voc\u00ea pode realizar em qualquer banco de dados persistente:</p> <ul> <li>Create (Criar): Adicionar novos registros ao banco de dados. No HTTP, essa a\u00e7\u00e3o geralmente \u00e9 associada ao verbo POST.</li> <li>Read (Ler): Recuperar registros existentes do banco de dados. No HTTP, essa a\u00e7\u00e3o geralmente \u00e9 associada ao verbo GET.</li> <li>Update (Atualizar): Modificar registros existentes no banco de dados. No HTTP, essa a\u00e7\u00e3o geralmente \u00e9 associada ao verbo PUT ou PATCH.</li> <li>Delete (Excluir): Remover registros existentes do banco de dados. No HTTP, essa a\u00e7\u00e3o geralmente \u00e9 associada ao verbo DELETE.</li> </ul> <p>Os c\u00f3digos de status HTTP s\u00e3o usados para indicar o resultado de cada opera\u00e7\u00e3o CRUD. Por exemplo, uma solicita\u00e7\u00e3o POST bem-sucedida (create) retorna o status HTTP 201 (Criado), enquanto uma solicita\u00e7\u00e3o GET bem-sucedida (read) retorna o status HTTP 200 (OK).</p> <p>\u00c9 importante notar que, ao trabalhar com FastAPI e Pydantic, nossos esquemas desempenham um papel vital na opera\u00e7\u00e3o de \"Create\" (criar). Ao usar a opera\u00e7\u00e3o POST para adicionar um novo registro ao nosso banco de dados, vamos aproveitar a valida\u00e7\u00e3o de dados do Pydantic para garantir que o novo registro esteja em conformidade com o esquema do nosso modelo de dados. Se os dados enviados na solicita\u00e7\u00e3o POST n\u00e3o passarem na valida\u00e7\u00e3o do Pydantic, nossa API retornar\u00e1 um c\u00f3digo de status HTTP 422 (Unprocessable Entity), indicando que os dados fornecidos s\u00e3o inv\u00e1lidos ou incompletos.</p> <p>Agora que temos uma compreens\u00e3o clara do que \u00e9 o CRUD, como se relaciona com os verbos HTTP, os c\u00f3digos de status e a valida\u00e7\u00e3o do Pydantic, podemos passar para a implementa\u00e7\u00e3o dessas opera\u00e7\u00f5es em nossa API FastAPI.</p> <p>Na nossa API, vamos criar rotas correspondentes para cada opera\u00e7\u00e3o CRUD, come\u00e7ando com a opera\u00e7\u00e3o \"create\" (criar), que ser\u00e1 implementada pela rota POST.</p>"},{"location":"02/#implementando-a-rota-post","title":"Implementando a Rota POST","text":"<p>A rota POST \u00e9 usada para criar um novo usu\u00e1rio em nosso sistema. Lembrando, o verbo HTTP POST est\u00e1 relacionado \u00e0 opera\u00e7\u00e3o \"Create\" do CRUD. Se tudo ocorrer como esperado e um novo usu\u00e1rio for criado com sucesso, a rota deve retornar o status HTTP 201 (Criado).</p> <p>Para a cria\u00e7\u00e3o dessa rota, vamos usar de base o JSON que criamos anteriormente. Para que a pessoa se cadastre na nossa plataforma, ela precisa enviar os dados de nome de usu\u00e1rio, email e senha:</p> <pre><code>{\n\"username\": \"joao123\",\n\"email\": \"joao123@email.com\",\n\"password\": \"segredo123\"\n}\n</code></pre> <p>Para isso, vamos criar um esquema Pydantic equivalente em um arquivo de esquemas: <code>fast_zero/schemas.py</code>:</p> fast_zero/schemas.py<pre><code>from pydantic import BaseModel, EmailStr\nclass UserSchema(BaseModel):\nusername: str\nemail: EmailStr\npassword: str\n</code></pre> <p>Agora vamos criar nosso endpoint que esperar\u00e1 receber esse esquema Pydantic e retornar\u00e1 201, caso o JSON enviado seja v\u00e1lido:</p> fast_zero/app.py<pre><code>from fastapi import FastAPI\nemafrom fast_zero.schemas import UserSchema\n# C\u00f3digo da nossa rota de ol\u00e1 mundo omitido\n@app.post('/users/', status_code=201)\ndef create_user(user: UserSchema):\nreturn user\n</code></pre> <p>Com esse endpoint criado, podemos executar a nossa aplica\u00e7\u00e3o:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task run\n</code></pre> <p>E acessar a p\u00e1gina http://localhost:8000/docs. Isso nos mostrar\u00e1 as defini\u00e7\u00f5es do nosso endpoint usando o Swagger.</p> <p></p> <p>Dessa forma, podemos testar de forma simplificada a nossa API, enviando o JSON e realizando alguns testes.</p> <p></p> <p>Entretanto, precisamos prestar aten\u00e7\u00e3o a um detalhe: nosso modelo retorna a senha do usu\u00e1rio, o que \u00e9 uma p\u00e9ssima pr\u00e1tica de seguran\u00e7a. </p> <p></p> <p>Para evitar isso, podemos criar um novo modelo que ser\u00e1 usado somente para resposta. Dessa forma, n\u00e3o expomos os dados que n\u00e3o queremos na API:</p> fast_zero/schemas.py<pre><code>class UserPublic(BaseModel):\nusername: str\nemail: EmailStr\n</code></pre> <p>Precisamos tamb\u00e9m dizer ao FastAPI que esse ser\u00e1 o modelo de resposta, e converter nosso <code>user</code> em <code>UserPublic</code>:</p> fast_zero/app.py<pre><code>from fast_zero.schemas import UserSchema, UserPublic\n# c\u00f3digo omitido\n@app.post('/users/', status_code=201, response_model=UserPublic)\ndef create_user(user: UserSchema):\nreturn UserPublic(**user.model_dump())\n</code></pre> <p>Agora, se fizermos de novo a chamada no Swagger, receberemos o mesmo objeto, mas sem expor a senha.</p> <p></p>"},{"location":"02/#criando-um-banco-de-dados-falso","title":"Criando um banco de dados falso","text":"<p>Finalmente, para brincar com essas rotas, podemos criar uma lista provis\u00f3ria para simular um banco de dados. Assim, podemos adicionar nossos dados e entender como o FastAPI funciona. Para isso, adicionamos uma lista provis\u00f3ria para o \"banco\" e alteramos nosso endpoint para inserir nossos modelos do Pydantic nessa lista:</p> fast_zero/app.py<pre><code>from fast_zero.schemas import UserSchema, UserPublic, UserDB\n# c\u00f3digo omitido\ndatabase = []  # provis\u00f3rio para estudo!\n@app.post('/users/', status_code=201, response_model=UserPublic)\ndef create_user(user: UserSchema):\nuser_with_id = UserDB(**user.model_dump(), id=len(database) + 1)\ndatabase.append(user_with_id)\nreturn UserPublic(**user_with_id.model_dump())\n</code></pre> <p>Se queremos uma simula\u00e7\u00e3o de banco de dados, precisamos ter um <code>ID</code> para cada usu\u00e1rio registrado no nosso \"banco\". Sendo assim, vamos alterar nosso modelo de resposta p\u00fablica (<code>UserPublic</code>) para que ele forne\u00e7a o ID de cria\u00e7\u00e3o do usu\u00e1rio. Vamos tamb\u00e9m criar um novo modelo que represente o usu\u00e1rio com sua senha e identificador, que chamaremos de <code>UserDB</code>:</p> fast_zero/schemas.py<pre><code>class UserPublic(BaseModel):\nid: int\nusername: str\nemail: EmailStr\nclass UserDB(UserSchema):\nid: int\n</code></pre> <p>Dessa forma, nada muda. No entanto, podemos prosseguir com a constru\u00e7\u00e3o dos outros endpoints. E lembre-se, \u00e9 importante testar esse endpoint para garantir que tudo esteja funcionando corretamente.</p>"},{"location":"02/#implementando-o-teste-da-rota-post","title":"Implementando o teste da rota POST","text":"<p>Antes de criar o teste de fato, vamos execut\u00e1-los para ver como anda a nossa cobertura:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n# parte da resposta foi omitida\n---------- coverage: platform linux, python 3.11.3-final-0 -----------\nName                    Stmts   Miss  Cover\n-------------------------------------------\nfast_zero/__init__.py       0      0   100%\nfast_zero/app.py           12      3    75%\nfast_zero/schemas.py       11      0   100%\n-------------------------------------------\nTOTAL                      23      3    87%\n\n# parte da resposta foi omitida\n</code></pre> <p>Vemos que temos 3 Miss. Poss\u00edvelmente das linhas que acabamos de escrever.</p> <p></p> <p>Ent\u00e3o, vamos escrever nosso teste. Esse teste para a rota POST precisa verificar se a cria\u00e7\u00e3o de um novo usu\u00e1rio funciona corretamente. N\u00f3s enviamos uma solicita\u00e7\u00e3o POST com um novo usu\u00e1rio para a rota /users/. Em seguida, verificamos se a resposta tem o status HTTP 201 (Criado) e se a resposta cont\u00e9m o novo usu\u00e1rio criado.</p> tests/test_app.py<pre><code>def test_create_user():\nresponse = client.post(\n'/users/',\njson={\n'username': 'alice',\n'email': 'alice@example.com',\n'password': 'secret',\n},\n)\nassert response.status_code == 201\nassert response.json() == {\n'username': 'alice',\n'email': 'alice@example.com',\n'id': 1,\n}\n</code></pre> <p>Ao executar o teste:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n# parte da resposta foi omitida\ntests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED\ntests/test_app.py::test_create_user PASSED\n\n---------- coverage: platform linux, python 3.11.3-final-0 -----------\nName                    Stmts   Miss  Cover\n-------------------------------------------\nfast_zero/__init__.py       0      0   100%\nfast_zero/app.py           12      0   100%\nfast_zero/schemas.py       11      0   100%\n-------------------------------------------\nTOTAL                      23      0   100%\n\n# parte da resposta foi omitida\n</code></pre> <p>Vemos que estamos no caminho certo. Agora que a rota POST est\u00e1 implementada, vamos seguir para a pr\u00f3xima opera\u00e7\u00e3o CRUD: Read.</p>"},{"location":"02/#implementando-a-rota-get","title":"Implementando a Rota GET","text":"<p>A rota GET \u00e9 usada para recuperar informa\u00e7\u00f5es de um ou mais usu\u00e1rios do nosso sistema. No contexto do CRUD, o verbo HTTP GET est\u00e1 associado \u00e0 opera\u00e7\u00e3o \"Read\". Se a solicita\u00e7\u00e3o for bem-sucedida, a rota deve retornar o status HTTP 200 (OK).</p> <p>Para estruturar a resposta dessa rota, podemos criar um novo modelo chamado <code>UserList</code>. Este modelo representar\u00e1 uma lista de usu\u00e1rios e cont\u00e9m apenas um campo chamado <code>users</code>, que \u00e9 uma lista de <code>UserPublic</code>. Isso nos permite retornar m\u00faltiplos usu\u00e1rios de uma vez.</p> fast_zero/schemas.py<pre><code>class UserList(BaseModel):\nusers: list[UserPublic]\n</code></pre> <p>Com esse modelo definido, podemos criar nosso endpoint GET. Este endpoint retornar\u00e1 uma inst\u00e2ncia de <code>UserList</code>, que por sua vez cont\u00e9m uma lista de <code>UserPublic</code>. Cada <code>UserPublic</code> \u00e9 criado a partir dos dados de um usu\u00e1rio em nosso banco de dados fict\u00edcio.</p> fast_zero/app.py<pre><code>from fast_zero.schemas import UserSchema, UserPublic, UserDB, UserList\n# c\u00f3digo omitido\n@app.get('/users/', response_model=UserList)\ndef read_users():\nreturn UserList(  # provis\u00f3rio\nusers=[UserPublic(**data.model_dump()) for data in database]\n)\n</code></pre> <p>Com essa implementa\u00e7\u00e3o, nossa API agora pode retornar uma lista de usu\u00e1rios. No entanto, nosso trabalho ainda n\u00e3o acabou. A pr\u00f3xima etapa \u00e9 escrever testes para garantir que nossa rota GET est\u00e1 funcionando corretamente. Isso nos ajudar\u00e1 a identificar e corrigir quaisquer problemas antes de prosseguirmos com a implementa\u00e7\u00e3o de outras rotas.</p>"},{"location":"02/#implementando-o-teste-da-rota-de-get","title":"Implementando o teste da rota de GET","text":"<p>Nosso teste da rota GET tem que verificar se a recupera\u00e7\u00e3o dos usu\u00e1rios est\u00e1 funcionando corretamente. N\u00f3s enviamos uma solicita\u00e7\u00e3o GET para a rota /users/. Em seguida, verificamos se a resposta tem o status HTTP 200 (OK) e se a resposta cont\u00e9m a lista de usu\u00e1rios.</p> tests/test_app.py<pre><code>def test_read_users():\nresponse = client.get('/users/')\nassert response.status_code == 200\nassert response.json() == {\n'users': [\n{\n'username': 'alice',\n'email': 'alice@example.com',\n'id': 1,\n}\n]\n}\n</code></pre> <p>Com as rotas POST e GET implementadas, agora podemos criar e recuperar usu\u00e1rios. Vamos implementar a pr\u00f3xima opera\u00e7\u00e3o CRUD: Update.</p>"},{"location":"02/#implementando-a-rota-put","title":"Implementando a Rota PUT","text":"<p>A rota PUT \u00e9 usada para atualizar as informa\u00e7\u00f5es de um usu\u00e1rio existente. No contexto do CRUD, o verbo HTTP PUT est\u00e1 associado \u00e0 opera\u00e7\u00e3o \"Update\". Se a solicita\u00e7\u00e3o for bem-sucedida, a rota deve retornar o status HTTP 200 (OK). No entanto, se o usu\u00e1rio solicitado n\u00e3o for encontrado, dever\u00edamos retornar o status HTTP 404 (N\u00e3o Encontrado).</p> fast_zero/app.py<pre><code>from fastapi import FastAPI, HTTPException\n# ...\n@app.put('/users/{user_id}', response_model=UserPublic)\ndef update_user(user_id: int, user: UserSchema):\nif user_id &gt; len(database) or user_id &lt; 1:\nraise HTTPException(status_code=404, detail='User not found')\nuser_with_id = UserPublic(**user.model_dump(), id=user_id)\ndatabase[user_id - 1] = user_with_id\nreturn UserPublic(**user_with_id.model_dump())\n</code></pre>"},{"location":"02/#implementando-o-teste-da-rota-de-put","title":"Implementando o teste da rota de PUT","text":"<p>Nosso teste da rota PUT precisa verificar se a atualiza\u00e7\u00e3o de um usu\u00e1rio existente funciona corretamente. N\u00f3s enviamos uma solicita\u00e7\u00e3o PUT com as novas informa\u00e7\u00f5es do usu\u00e1rio para a rota <code>/users/{user_id}</code>. Em seguida, verificamos se a resposta tem o status HTTP 200 (OK) e se a resposta cont\u00e9m o usu\u00e1rio atualizado.</p> tests/test_app.py<pre><code>def test_update_user():\nresponse = client.put(\n'/users/1',\njson={\n'username': 'bob',\n'email': 'bob@example.com',\n'password': 'mynewpassword',\n},\n)\nassert response.status_code == 200\nassert response.json() == {\n'username': 'bob',\n'email': 'bob@example.com',\n'id': 1,\n}\n</code></pre> <p>Com as rotas POST, GET e PUT implementadas, agora podemos criar, recuperar e atualizar usu\u00e1rios. A \u00faltima opera\u00e7\u00e3o CRUD que precisamos implementar \u00e9 Delete.</p>"},{"location":"02/#implementando-a-rota-delete","title":"Implementando a Rota DELETE","text":"<p>A rota DELETE \u00e9 usada para excluir um usu\u00e1rio do nosso sistema. No contexto do CRUD, o verbo HTTP DELETE est\u00e1 associado \u00e0 opera\u00e7\u00e3o \"Delete\". Se a solicita\u00e7\u00e3o for bem-sucedida, a rota deve retornar o status HTTP 200 (OK). No entanto, se o usu\u00e1rio solicitado n\u00e3o for encontrado, dever\u00edamos retornar o status HTTP 404 (N\u00e3o Encontrado).</p> <p>Para transmitir uma mensagem de sucesso ou falha na opera\u00e7\u00e3o de exclus\u00e3o, podemos criar um modelo chamado <code>Message</code>. Esse modelo ser\u00e1 respons\u00e1vel por embalar uma mensagem que ser\u00e1 retornada na nossa API.</p> fast_zero/schemas.py<pre><code>class Message(BaseModel):\ndetail: str\n</code></pre> <p>Agora podemos criar nosso endpoint DELETE. Este endpoint receber\u00e1 o ID do usu\u00e1rio que queremos excluir. Note que, estamos lan\u00e7ando uma exce\u00e7\u00e3o HTTP quando o ID do usu\u00e1rio est\u00e1 fora do range da nossa lista (simula\u00e7\u00e3o do nosso banco de dados). Quando conseguimos excluir o usu\u00e1rio com sucesso, retornamos a mensagem de sucesso em um modelo do tipo <code>Message</code>.</p> fast_zero/app.py<pre><code>from fast_zero.schemas import UserSchema, UserPublic, UserDB, UserList, Message\n# ...\n@app.delete('/users/{user_id}', response_model=Message)\ndef delete_user(user_id: int):\nif user_id &gt; len(database) or user_id &lt; 1:\nraise HTTPException(status_code=404, detail='User not found')\ndel database[user_id - 1]\nreturn {'detail': 'User deleted'}\n</code></pre> <p>Com a implementa\u00e7\u00e3o da rota DELETE conclu\u00edda, \u00e9 fundamental garantirmos que essa rota est\u00e1 funcionando conforme o esperado. Para isso, precisamos escrever testes para essa rota.</p>"},{"location":"02/#implementados-os-testes-para-rota-de-delte","title":"Implementados os testes para rota de DELTE","text":"<p>Nosso teste da rota DELETE precisa verificar se a exclus\u00e3o de um usu\u00e1rio existente funciona corretamente. N\u00f3s enviamos uma solicita\u00e7\u00e3o DELETE para a rota /users/{user_id}. Em seguida, verificamos se a resposta tem o status HTTP 200 (OK) e se a resposta cont\u00e9m uma mensagem informando que o usu\u00e1rio foi exclu\u00eddo.</p> tests/test_app.py<pre><code>def test_delete_user():\nresponse = client.delete('/users/1')\nassert response.status_code == 200\nassert response.json() == {'detail': 'User deleted'}\n</code></pre>"},{"location":"02/#commit","title":"Commit","text":"<p>Ap\u00f3s toda essa jornada de aprendizado, constru\u00e7\u00e3o e teste de rotas, chegou a hora de registrar nosso progresso utilizando o git. Fazer commits regulares \u00e9 uma boa pr\u00e1tica, pois mant\u00e9m um hist\u00f3rico detalhado das altera\u00e7\u00f5es e facilita a volta a uma vers\u00e3o anterior do c\u00f3digo, se necess\u00e1rio.</p> <p>Primeiramente, vamos verificar as altera\u00e7\u00f5es feitas no projeto com o comando <code>git status</code>. Este comando nos mostrar\u00e1 todos os arquivos modificados que ainda n\u00e3o foram inclu\u00eddos em um commit.</p> <pre><code>$ git status\n</code></pre> <p>Em seguida, vamos adicionar todas as altera\u00e7\u00f5es para o pr\u00f3ximo commit. O comando <code>git add .</code> adiciona todas as altera\u00e7\u00f5es feitas em todos os arquivos do projeto.</p> <pre><code>$ git add .\n</code></pre> <p>Agora, estamos prontos para fazer o commit. Com o comando <code>git commit</code>, criamos uma nova entrada no hist\u00f3rico do nosso projeto. \u00c9 importante adicionar uma mensagem descritiva ao commit, para que outras pessoas (ou n\u00f3s mesmos, no futuro) possam entender o que foi alterado. Nesse caso, a mensagem do commit poderia ser \"Implementando rotas CRUD\".</p> <pre><code>$ git commit -m \"Implementando rotas CRUD\"\n</code></pre> <p>Por fim, enviamos nossas altera\u00e7\u00f5es para o reposit\u00f3rio remoto com <code>git push</code>. Se voc\u00ea tiver v\u00e1rias branches, certifique-se de estar na branch correta antes de executar este comando.</p> <pre><code>$ git push\n</code></pre> <p>E pronto! As altera\u00e7\u00f5es est\u00e3o seguras no hist\u00f3rico do git, e podemos continuar com o pr\u00f3ximo passo do projeto.</p>"},{"location":"02/#conclusao","title":"Conclus\u00e3o","text":"<p>Com a implementa\u00e7\u00e3o bem-sucedida das rotas CRUD, demos um passo significativo na constru\u00e7\u00e3o de uma API robusta e funcional com FastAPI. Agora temos a capacidade de manipular usu\u00e1rios - criar, ler, atualizar e excluir - o que \u00e9 fundamental para muitos sistemas de informa\u00e7\u00e3o.</p> <p>O papel dos testes em cada etapa n\u00e3o pode ser subestimado. Testes n\u00e3o apenas nos ajudam a assegurar que nosso c\u00f3digo est\u00e1 funcionando como esperado, mas tamb\u00e9m nos permitem refinar nossas solu\u00e7\u00f5es e detectar problemas potenciais antes que eles afetem a funcionalidade geral do nosso sistema. Nunca subestime a import\u00e2ncia de executar seus testes sempre que fizer uma altera\u00e7\u00e3o em seu c\u00f3digo!</p> <p>At\u00e9 aqui, no entanto, trabalhamos com um \"banco de dados\" provis\u00f3rio, na forma de uma lista Python, que \u00e9 vol\u00e1til e n\u00e3o persiste os dados de uma execu\u00e7\u00e3o do aplicativo para outra. Para nosso aplicativo ser \u00fatil em um cen\u00e1rio do mundo real, precisamos armazenar nossos dados de forma mais duradoura. \u00c9 a\u00ed que os bancos de dados entram.</p> <p>No pr\u00f3ximo t\u00f3pico, vamos explorar uma das partes mais cr\u00edticas de qualquer aplicativo - a conex\u00e3o e intera\u00e7\u00e3o com um banco de dados. Vamos aprender a integrar nosso aplicativo FastAPI com um banco de dados real, permitindo a persist\u00eancia de nossos dados de usu\u00e1rio entre as sess\u00f5es do aplicativo.</p>"},{"location":"03/","title":"[OK] Configurando o Banco de Dados e Gerenciando Migra\u00e7\u00f5es com Alembic","text":""},{"location":"03/#ok-configurando-o-banco-de-dados-e-gerenciando-migracoes-com-alembic","title":"[OK] Configurando o Banco de Dados e Gerenciando Migra\u00e7\u00f5es com Alembic","text":"<p>Objetivos dessa aula:</p> <ul> <li>Introdu\u00e7\u00e3o ao SQLAlchemy e Alembic</li> <li>Instalando SQLAlchemy e Alembic</li> <li>Configurando e criando o banco de dados</li> <li>Criando e localizando tabelas utilizando SQLAlchemy</li> <li>Testando a cria\u00e7\u00e3o de tabelas</li> <li>Gerenciando migra\u00e7\u00f5es do banco de dados com Alembic</li> </ul> Caso prefira ver a aula em v\u00eddeo <p></p> <p>Aula  Slides  C\u00f3digo </p> <p>Ol\u00e1 a todos! Se voc\u00ea est\u00e1 chegando agora, recomendamos verificar as aulas anteriores de nosso curso \"FastAPI do Zero: Criando um Projeto com Bancos de Dados, Testes e Deploy\". Hoje, vamos mergulhar no SQLAlchemy e no Alembic, e come\u00e7aremos a configurar nosso banco de dados.</p> <p>Antes de mergulharmos na instala\u00e7\u00e3o e configura\u00e7\u00e3o, vamos esclarecer alguns conceitos.</p>"},{"location":"03/#o-que-e-um-orm-e-por-que-usamos-um","title":"O que \u00e9 um ORM e por que usamos um?","text":"<p>ORM significa Mapeamento Objeto-Relacional. \u00c9 uma t\u00e9cnica de programa\u00e7\u00e3o que vincula (ou mapeia) objetos a registros de banco de dados. Em outras palavras, um ORM permite que voc\u00ea interaja com seu banco de dados, como se voc\u00ea estivesse trabalhando com objetos Python.</p> <p>O SQLAlchemy \u00e9 um exemplo de ORM. Ele permite que voc\u00ea trabalhe com bancos de dados SQL de maneira mais natural aos programadores Python. Em vez de escrever consultas SQL cruas, voc\u00ea pode usar m\u00e9todos e atributos Python para manipular seus registros de banco de dados.</p> <p>Mas por que usar\u00edamos um ORM? Aqui est\u00e3o algumas raz\u00f5es:</p> <ul> <li> <p>Abstra\u00e7\u00e3o de banco de dados: ORMs permitem que voc\u00ea mude de um tipo de banco de dados para outro com poucas altera\u00e7\u00f5es no c\u00f3digo.</p> </li> <li> <p>Seguran\u00e7a: ORMs geralmente lidam com escapar de consultas e prevenir inje\u00e7\u00f5es SQL, um tipo comum de vulnerabilidade de seguran\u00e7a.</p> </li> <li> <p>Efici\u00eancia no desenvolvimento: ORMs podem gerar automaticamente esquemas, realizar migra\u00e7\u00f5es e outras tarefas que seriam demoradas para fazer manualmente.</p> </li> </ul>"},{"location":"03/#configuracoes-de-ambiente-e-as-12-fatores","title":"Configura\u00e7\u00f5es de ambiente e as 12 fatores","text":"<p>Uma boa pr\u00e1tica no desenvolvimento de aplica\u00e7\u00f5es \u00e9 separar as configura\u00e7\u00f5es do c\u00f3digo. Configura\u00e7\u00f5es, como credenciais de banco de dados, s\u00e3o propensas a mudan\u00e7as entre ambientes diferentes (como desenvolvimento, teste e produ\u00e7\u00e3o). Mistur\u00e1-las com o c\u00f3digo pode tornar o processo de mudan\u00e7a entre esses ambientes complicado e propenso a erros.</p> <p>Al\u00e9m disso, expor credenciais de banco de dados e outras informa\u00e7\u00f5es sens\u00edveis no c\u00f3digo-fonte \u00e9 uma pr\u00e1tica de seguran\u00e7a ruim. Se esse c\u00f3digo fosse comprometido, essas informa\u00e7\u00f5es poderiam ser usadas para acessar e manipular seus recursos.</p> <p>Por isso, usaremos o <code>pydantic-settings</code> para gerenciar nossas configura\u00e7\u00f5es de ambiente. A biblioteca permite que voc\u00ea defina configura\u00e7\u00f5es em arquivos separados ou vari\u00e1veis de ambiente e acesse-as de uma maneira estruturada e segura em seu c\u00f3digo.</p> <p>Isso est\u00e1 alinhado com a metodologia dos 12 fatores, um conjunto de melhores pr\u00e1ticas para desenvolvimento de aplica\u00e7\u00f5es modernas. O terceiro fator, \"Config\", afirma que as configura\u00e7\u00f5es que variam entre os ambientes devem ser armazenadas no ambiente e n\u00e3o no c\u00f3digo.</p> <p>Agora que entendemos melhor esses conceitos, vamos come\u00e7ar instalando as bibliotecas que vamos usar. O primeiro passo \u00e9 instalar o SQLAlchemy, um ORM que nos permite trabalhar com bancos de dados SQL de maneira Pythonic. Al\u00e9m disso, o Alembic, que \u00e9 uma ferramenta de migra\u00e7\u00e3o de banco de dados, funciona muito bem com o SQLAlchemy e nos ajudar\u00e1 a gerenciar as altera\u00e7\u00f5es do esquema do nosso banco de dados.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry add sqlalchemy\n</code></pre> <p>Al\u00e9m disso, para evitar a escrita de configura\u00e7\u00f5es do banco de dados diretamente no c\u00f3digo-fonte, usaremos o <code>pydantic-settings</code>. Este pacote nos permite gerenciar as configura\u00e7\u00f5es do nosso aplicativo de uma maneira mais segura e estruturada.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry add pydantic-settings\n</code></pre> <p>Agora estamos prontos para mergulhar na configura\u00e7\u00e3o do nosso banco de dados! Vamos em frente.</p>"},{"location":"03/#definindo-os-modelos-de-dados-com-sqlalchemy","title":"Definindo os Modelos de Dados com SQLAlchemy","text":"<p>O primeiro passo \u00e9 definir nosso modelo de usu\u00e1rio. Um modelo de dados \u00e9 a representa\u00e7\u00e3o de como nossos dados ser\u00e3o armazenados no banco de dados. Neste caso, o modelo <code>User</code> representar\u00e1 a tabela <code>users</code> em nosso banco de dados.</p> <p>Vamos criar um novo arquivo <code>models.py</code> no diret\u00f3rio <code>fast_zero</code>.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>touch fast_zero/models.py\n</code></pre> <p>Adicione o seguinte c\u00f3digo no arquivo <code>models.py</code>:</p> fast_zero/models.py<pre><code>from sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\nclass Base(DeclarativeBase):\npass\nclass User(Base):\n__tablename__ = 'users'\nid: Mapped[int] = mapped_column(primary_key=True)\nusername: Mapped[str]\npassword: Mapped[str]\nemail: Mapped[str]\n</code></pre>"},{"location":"03/#escrevendo-os-testes-para-as-tabelas","title":"Escrevendo os Testes para as Tabelas","text":"<p>Ao desenvolver software, \u00e9 uma boa pr\u00e1tica criar testes para cada nova funcionalidade implementada. Neste caso, depois de criar nosso modelo de usu\u00e1rio, precisamos garantir que ele funcione como esperado. Para isso, vamos criar dois novos arquivos de teste, <code>conftest.py</code> e <code>test_db.py</code>.</p> <p>O arquivo <code>conftest.py</code> \u00e9 usado pelo pytest para definir prepara\u00e7\u00f5es necess\u00e1rias antes da execu\u00e7\u00e3o dos testes ou configura\u00e7\u00f5es comuns a v\u00e1rios testes. \u00c9 um lugar centralizado para as chamadas fixtures.</p> <p>J\u00e1 o arquivo <code>test_db.py</code> \u00e9 onde vamos escrever os testes para nosso modelo de usu\u00e1rio. Isso ajuda a garantir que nossas tabelas est\u00e3o sendo criadas corretamente e que podem armazenar e recuperar informa\u00e7\u00f5es conforme esperado.</p> <p>Para criar esses arquivos, execute o seguinte comando:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>touch tests/test_db.py\ntouch tests/conftest.py\n</code></pre> <p>No arquivo <code>conftest.py</code>, vamos introduzir uma fixture aos nossos testes pytest chamada \"session\". As fixtures do pytest s\u00e3o fun\u00e7\u00f5es que s\u00e3o executadas antes de cada teste para fornecer um ambiente de teste consistente. Neste caso, a fixture \"session\" est\u00e1 criando uma nova inst\u00e2ncia do banco de dados SQLite em mem\u00f3ria para cada teste. Isso permite que cada teste funcione isoladamente, garantindo que eles n\u00e3o interfiram uns nos outros.</p> tests/conftest.py<pre><code>import pytest\nfrom sqlalchemy import create_engine, select\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy.pool import StaticPool\nfrom fast_zero.models import Base\n@pytest.fixture\ndef session():\nengine = create_engine(\n'sqlite:///:memory:',\nconnect_args={'check_same_thread': False},\npoolclass=StaticPool,\n)\nSession = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase.metadata.create_all(engine)\nyield Session()\nBase.metadata.drop_all(engine)\n</code></pre> <p>Agora, no arquivo <code>test_db.py</code>, vamos escrever um teste para a cria\u00e7\u00e3o de um usu\u00e1rio. Este teste adiciona um novo usu\u00e1rio ao banco de dados, faz commit das mudan\u00e7as, e depois verifica se o usu\u00e1rio foi devidamente criado consultando-o pelo nome de usu\u00e1rio. Se o usu\u00e1rio foi criado corretamente, o teste passa. Caso contr\u00e1rio, o teste falha, indicando que h\u00e1 algo errado com nossa fun\u00e7\u00e3o de cria\u00e7\u00e3o de usu\u00e1rio.</p> tests/test_db.py<pre><code>from sqlalchemy import select\nfrom fast_zero.models import User\ndef test_create_user(session):\nnew_user = User(username='alice', password='secret', email='teste@test')\nsession.add(new_user)\nsession.commit()\nuser = session.scalar(select(User).where(User.username == 'alice'))\nassert user.username == 'alice'\n</code></pre>"},{"location":"03/#executando-o-teste","title":"Executando o teste","text":"<p>A execu\u00e7\u00e3o de testes \u00e9 uma parte vital do desenvolvimento de qualquer aplica\u00e7\u00e3o. Os testes nos ajudam a identificar e corrigir problemas antes que eles se tornem mais s\u00e9rios. Eles tamb\u00e9m fornecem a confian\u00e7a de que nossas mudan\u00e7as n\u00e3o quebraram nenhuma funcionalidade existente. No nosso caso, vamos executar os testes para validar nossos modelos de usu\u00e1rio e garantir que eles estejam funcionando como esperado.</p> <p>Para executar os testes, digite o seguinte comando:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n# ...\ntests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED\ntests/test_app.py::test_create_user PASSED\ntests/test_app.py::test_read_users PASSED\ntests/test_app.py::test_update_user PASSED\ntests/test_app.py::test_delete_user PASSED\ntests/test_db.py::test_create_user PASSED\n\n---------- coverage: platform linux, python 3.11.3-final-0 -----------\nName                    Stmts   Miss  Cover\n-------------------------------------------\nfast_zero/__init__.py       0      0   100%\nfast_zero/app.py           28      2    93%\nfast_zero/models.py        11      0   100%\nfast_zero/schemas.py       15      0   100%\n-------------------------------------------\nTOTAL                      54      2    96%\n</code></pre> <p>Neste caso, podemos ver que todos os nossos testes passaram com sucesso. Isso significa que nossa funcionalidade de cria\u00e7\u00e3o de usu\u00e1rio est\u00e1 funcionando corretamente e que nosso modelo de usu\u00e1rio est\u00e1 sendo corretamente persistido no banco de dados.</p> <p>Com nossos modelos e testes de banco de dados agora em ordem, estamos prontos para avan\u00e7ar para a pr\u00f3xima fase de configura\u00e7\u00e3o de nosso banco de dados e gerenciamento de migra\u00e7\u00f5es.</p>"},{"location":"03/#configuracao-do-ambiente-do-banco-de-dados","title":"Configura\u00e7\u00e3o do ambiente do banco de dados","text":"<p>Por fim, vamos configurar nosso banco de dados. Primeiro, vamos criar um novo arquivo chamado <code>settings.py</code> dentro do diret\u00f3rio <code>fast_zero</code>. Aqui, usaremos o Pydantic para criar uma classe <code>Settings</code> que ir\u00e1 pegar as configura\u00e7\u00f5es do nosso arquivo <code>.env</code>.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>touch fast_zero/settings.py\n</code></pre> <p>No arquivo <code>settings.py</code>, a classe <code>Settings</code> \u00e9 definida como:</p> fast_zero/settings.py<pre><code>from pydantic_settings import BaseSettings, SettingsConfigDict\nclass Settings(BaseSettings):\nmodel_config = SettingsConfigDict(\nenv_file='.env', env_file_encoding='utf-8'\n)\nDATABASE_URL: str\n</code></pre> <p>Agora, vamos definir o <code>DATABASE_URL</code> no nosso arquivo de ambiente <code>.env</code>. Crie o arquivo na raiz do projeto e adicione a seguinte linha:</p> .env<pre><code>DATABASE_URL=\"sqlite:///database.db\"\n</code></pre> <p>Com isso, quando a classe <code>Settings</code> for instanciada, ela ir\u00e1 automaticamente carregar as configura\u00e7\u00f5es do arquivo <code>.env</code>.</p> <p>Finalmente, adicione o arquivo de banco de dados, <code>database.db</code>, ao <code>.gitignore</code> para garantir que n\u00e3o seja inclu\u00eddo no controle de vers\u00e3o. Adicionar informa\u00e7\u00f5es sens\u00edveis ou arquivos bin\u00e1rios ao controle de vers\u00e3o \u00e9 geralmente considerado uma pr\u00e1tica ruim.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>echo 'database.db' &gt;&gt; .gitignore\n</code></pre>"},{"location":"03/#instalando-o-alembic-e-criando-a-primeira-migracao","title":"Instalando o Alembic e Criando a Primeira Migra\u00e7\u00e3o","text":"<p>Antes de avan\u00e7armos, \u00e9 importante entender o que s\u00e3o migra\u00e7\u00f5es de banco de dados e por que s\u00e3o \u00fateis. As migra\u00e7\u00f5es s\u00e3o uma maneira de fazer altera\u00e7\u00f5es ou atualiza\u00e7\u00f5es no banco de dados, como adicionar uma tabela ou uma coluna a uma tabela, ou alterar o tipo de dados de uma coluna. Elas s\u00e3o extremamente \u00fateis, pois nos permitem manter o controle de todas as altera\u00e7\u00f5es feitas no esquema do banco de dados ao longo do tempo. Elas tamb\u00e9m nos permitem reverter para uma vers\u00e3o anterior do esquema do banco de dados, se necess\u00e1rio.</p> <p>Agora, vamos come\u00e7ar instalando o Alembic, que \u00e9 uma ferramenta de migra\u00e7\u00e3o de banco de dados para SQLAlchemy. Usaremos o Poetry para adicionar o Alembic ao nosso projeto:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry add alembic\n</code></pre> <p>Ap\u00f3s a instala\u00e7\u00e3o do Alembic, precisamos inici\u00e1-lo em nosso projeto. O comando de inicializa\u00e7\u00e3o criar\u00e1 um diret\u00f3rio <code>migrations</code> e um arquivo de configura\u00e7\u00e3o <code>alembic.ini</code>:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>alembic init migrations\n</code></pre> <p>Com isso, a estrutura do nosso projeto sofre algumas altera\u00e7\u00f5es e novos arquivos s\u00e3o criados:</p> <pre><code>.\n\u251c\u2500\u2500 .env\n\u251c\u2500\u2500 alembic.ini\n\u251c\u2500\u2500 fast_zero\n\u2502  \u251c\u2500\u2500 __init__.py\n\u2502  \u251c\u2500\u2500 app.py\n\u2502  \u251c\u2500\u2500 models.py\n\u2502  \u2514\u2500\u2500 schemas.py\n\u251c\u2500\u2500 migrations\n\u2502  \u251c\u2500\u2500 env.py\n\u2502  \u251c\u2500\u2500 README\n\u2502  \u251c\u2500\u2500 script.py.mako\n\u2502  \u2514\u2500\u2500 versions\n\u251c\u2500\u2500 poetry.lock\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 README.md\n\u2514\u2500\u2500 tests\n   \u251c\u2500\u2500 __init__.py\n   \u251c\u2500\u2500 conftest.py\n   \u251c\u2500\u2500 test_app.py\n   \u2514\u2500\u2500 test_db.py\n</code></pre> <p>No arquivo <code>alembic.ini</code>: ficam as configura\u00e7\u00f5es gerais das nossas migra\u00e7\u00f5es. Na pasta <code>migrate</code> foram criados um arquivo chamado <code>env.py</code>, esse arquivo \u00e9 respons\u00e1vel por como as migra\u00e7\u00f5es ser\u00e3o feitas e o arquivo <code>script.py.mako</code> \u00e9 um template para as novas migra\u00e7\u00f5es.</p>"},{"location":"03/#criando-uma-migracao-automatica","title":"Criando uma migra\u00e7\u00e3o autom\u00e1tica","text":"<p>Com o Alembic devidamente instalado e iniciado, agora \u00e9 o momento de gerar nossa primeira migra\u00e7\u00e3o. Mas, antes disso, precisamos garantir que o Alembic consiga acessar nossas configura\u00e7\u00f5es e modelos corretamente. Para isso, vamos fazer algumas altera\u00e7\u00f5es no arquivo <code>migrations/env.py</code>.</p> <p>Neste arquivo, precisamos:</p> <ol> <li>Importar as <code>Settings</code> do nosso arquivo <code>settings.py</code> e a <code>Base</code> dos nossos modelos.</li> <li>Configurar a URL do SQLAlchemy para ser a mesma que definimos em <code>Settings</code>.</li> <li>Verificar a exist\u00eancia do arquivo de configura\u00e7\u00e3o do Alembic e, se presente, l\u00ea-lo.</li> <li>Definir os metadados de destino como <code>Base.metadata</code>, que \u00e9 o que o Alembic utilizar\u00e1 para gerar automaticamente as migra\u00e7\u00f5es.</li> </ol> <p>O arquivo <code>migrations/env.py</code> modificado ficar\u00e1 assim:</p> migrations/env.py<pre><code>from alembic import context\nfrom fast_zero.settings import Settings\nfrom fast_zero.models import Base\nconfig = context.config\nconfig.set_main_option('sqlalchemy.url', Settings().DATABASE_URL)\nif config.config_file_name is not None:\nfileConfig(config.config_file_name)\ntarget_metadata = Base.metadata\n</code></pre> <p>Feitas essas altera\u00e7\u00f5es, estamos prontos para gerar nossa primeira migra\u00e7\u00e3o autom\u00e1tica. O Alembic \u00e9 capaz de gerar migra\u00e7\u00f5es a partir das mudan\u00e7as detectadas nos nossos modelos do SQLAlchemy.</p> <p>Para criar a migra\u00e7\u00e3o, utilizamos o seguinte comando:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>alembic revision --autogenerate -m \"create users table\"\n</code></pre> <p>Este comando instrui o Alembic a criar uma nova revis\u00e3o de migra\u00e7\u00e3o no diret\u00f3rio <code>migrations/versions</code>. A revis\u00e3o gerada conter\u00e1 os comandos SQL necess\u00e1rios para aplicar a migra\u00e7\u00e3o (criar a tabela de usu\u00e1rios) e para reverter essa migra\u00e7\u00e3o, caso seja necess\u00e1rio.</p>"},{"location":"03/#analisando-a-migracao-automatica","title":"Analisando a migra\u00e7\u00e3o autom\u00e1tica","text":"<p>Ao criar uma migra\u00e7\u00e3o autom\u00e1tica com o Alembic, um arquivo \u00e9 gerado dentro da pasta <code>migrations/versions</code>. O nome deste arquivo come\u00e7a com um ID de revis\u00e3o (um hash \u00fanico gerado pelo Alembic), seguido por uma breve descri\u00e7\u00e3o que fornecemos no momento da cria\u00e7\u00e3o da migra\u00e7\u00e3o, neste caso, <code>create_users_table</code>.</p> <p>Vamos analisar o arquivo de migra\u00e7\u00e3o:</p> migrations/versions/e018397cecf4_create_users_table.py<pre><code>\"\"\"create users table\nRevision ID: e018397cecf4\nRevises: \nCreate Date: 2023-07-13 03:43:03.730534\n\"\"\"\nfrom alembic import op\nimport sqlalchemy as sa\n# revision identifiers, used by Alembic.\nrevision = 'e018397cecf4'\ndown_revision = None\nbranch_labels = None\ndepends_on = None\ndef upgrade() -&gt; None:\n# ### commands auto generated by Alembic - please adjust! ###\nop.create_table('users',\nsa.Column('id', sa.Integer(), nullable=False),\nsa.Column('username', sa.String(), nullable=False),\nsa.Column('password', sa.String(), nullable=False),\nsa.Column('email', sa.String(), nullable=False),\nsa.PrimaryKeyConstraint('id')\n)\n# ### end Alembic commands ###\ndef downgrade() -&gt; None:\n# ### commands auto generated by Alembic - please adjust! ###\nop.drop_table('users')\n# ### end Alembic commands ###\n</code></pre> <p>Esse arquivo descreve as mudan\u00e7as a serem feitas no banco de dados. Ele usa a linguagem core do SQLAlchemy, que \u00e9 mais baixo n\u00edvel que o ORM. As fun\u00e7\u00f5es <code>upgrade</code> e <code>downgrade</code> definem, respectivamente, o que fazer para aplicar e para desfazer a migra\u00e7\u00e3o. No nosso caso, a fun\u00e7\u00e3o <code>upgrade</code> cria a tabela 'users' com os campos que definimos em <code>fast_zero/models.py</code>e a fun\u00e7\u00e3o <code>downgrade</code> a remove.</p> <p>Apesar desta migra\u00e7\u00e3o ter sido criada, ela ainda n\u00e3o foi aplicada ao nosso banco de dados. No entanto, o Alembic j\u00e1 criou um arquivo <code>database.db</code>, conforme especificamos no arquivo <code>.env</code> e que foi lido pela classe <code>Settings</code> do Pydantic. Al\u00e9m disso, ele criou uma tabela <code>alembic_version</code> no banco de dados para controlar as vers\u00f5es das migra\u00e7\u00f5es que foram aplicadas.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>sqlite3 database.db SQLite version 3.42.0 2023-05-16 12:36:15\nEnter \".help\" for usage hints.\nsqlite&gt; .schema\nCREATE TABLE alembic_version (\nversion_num VARCHAR(32) NOT NULL, CONSTRAINT alembic_version_pkc PRIMARY KEY (version_num)\n);\nsqlite&gt; .exit\n</code></pre> <p>Para aplicar as migra\u00e7\u00f5es, usamos o comando <code>upgrade</code> do CLI Alembic. O argumento <code>head</code> indica que queremos aplicar todas as migra\u00e7\u00f5es que ainda n\u00e3o foram aplicadas:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>alembic upgrade head\nINFO  [alembic.runtime.migration] Context impl SQLiteImpl.\nINFO  [alembic.runtime.migration] Will assume non-transactional DDL.\nINFO  [alembic.runtime.migration] Running upgrade  -&gt; e018397cecf4, create users table\n</code></pre> <p>Agora, se examinarmos nosso banco de dados novamente, veremos que a tabela users foi criada:</p> <pre><code>sqlite3 database.db SQLite version 3.42.0 2023-05-16 12:36:15\nEnter \".help\" for usage hints.\nsqlite&gt; .schema\nCREATE TABLE alembic_version (\nversion_num VARCHAR(32) NOT NULL, CONSTRAINT alembic_version_pkc PRIMARY KEY (version_num)\n);\nCREATE TABLE users (\nid INTEGER NOT NULL, username VARCHAR NOT NULL, password VARCHAR NOT NULL, email VARCHAR NOT NULL, PRIMARY KEY (id)\n);\nsqlite&gt; .exit\n</code></pre> <p>Finalmente, lembre-se de que todas essas mudan\u00e7as que fizemos s\u00f3 existem localmente no seu ambiente de trabalho at\u00e9 agora. Para que sejam compartilhadas com outras pessas, precisamos fazer commit dessas mudan\u00e7as no nosso sistema de controle de vers\u00e3o.</p>"},{"location":"03/#commit","title":"Commit","text":"<p>Primeiro, vamos verificar o status do nosso reposit\u00f3rio para ver as mudan\u00e7as que fizemos:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git status\n</code></pre> <p>Voc\u00ea ver\u00e1 uma lista de arquivos que foram modificados ou adicionados. As altera\u00e7\u00f5es devem incluir os arquivos de migra\u00e7\u00e3o que criamos, bem como quaisquer altera\u00e7\u00f5es que fizemos em nossos arquivos de modelo e configura\u00e7\u00e3o.</p> <p>Em seguida, vamos adicionar todas as mudan\u00e7as ao pr\u00f3ximo commit:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git add .\n</code></pre> <p>Agora, estamos prontos para fazer o commit das nossas altera\u00e7\u00f5es. Vamos fornecer uma mensagem de commit que descreve as mudan\u00e7as que fizemos:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git commit -m \"Adicionada a primeira migra\u00e7\u00e3o com Alembic. Criada tabela de usu\u00e1rios.\"\n</code></pre> <p>Finalmente, vamos enviar as mudan\u00e7as para o reposit\u00f3rio remoto:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git push\n</code></pre> <p>E pronto! As mudan\u00e7as que fizemos foram salvas no hist\u00f3rico do Git e agora est\u00e3o dispon\u00edveis no git.</p>"},{"location":"03/#conclusao","title":"Conclus\u00e3o","text":"<p>Nesta aula, demos passos significativos para preparar nosso projeto FastAPI para interagir com um banco de dados. Come\u00e7amos definindo nosso primeiro modelo de dados, o <code>User</code>, utilizando o SQLAlchemy. Al\u00e9m disso, em conformidade com as pr\u00e1ticas de Desenvolvimento Orientado por Testes (TDD), implementamos um teste para assegurar que a funcionalidade de cria\u00e7\u00e3o de um novo usu\u00e1rio no banco de dados esteja operando corretamente.</p> <p>Avan\u00e7amos para configurar o ambiente de desenvolvimento, onde estabelecemos um arquivo <code>.env</code> para armazenar nossa <code>DATABASE_URL</code> e ajustamos o SQLAlchemy para utilizar essa URL. Complementarmente, inclu\u00edmos o arquivo do banco de dados ao <code>.gitignore</code> para evitar que seja rastreado pelo controle de vers\u00e3o.</p> <p>Na \u00faltima parte desta aula, focamos na instala\u00e7\u00e3o e configura\u00e7\u00e3o do Alembic, uma ferramenta de migra\u00e7\u00e3o de banco de dados para SQLAlchemy. Usando o Alembic, criamos nossa primeira migra\u00e7\u00e3o que, automaticamente, gera o esquema do banco de dados a partir dos nossos modelos SQLAlchemy.</p> <p>Com esses passos, nosso projeto est\u00e1 bem encaminhado para come\u00e7ar a persistir dados. Na pr\u00f3xima aula, avan\u00e7aremos para a fase crucial de conectar o SQLAlchemy aos endpoints do nosso projeto. Isso permitir\u00e1 a realiza\u00e7\u00e3o de opera\u00e7\u00f5es de CRUD nos nossos usu\u00e1rios diretamente atrav\u00e9s da API.</p>"},{"location":"04/","title":"[OK] Integrando Banco de Dados a API","text":""},{"location":"04/#ok-integrando-banco-de-dados-a-api","title":"[OK] Integrando Banco de Dados a API","text":"<p>Objetivos dessa aula:</p> <ul> <li>Integrando SQLAlchemy \u00e0 nossa aplica\u00e7\u00e3o FastAPI</li> <li>Utilizando a fun\u00e7\u00e3o Depends para gerenciar depend\u00eancias</li> <li>Modificando endpoints para interagir com o banco de dados</li> <li>Testando os novos endpoints com Pytest e fixtures</li> </ul> Caso prefira ver a aula em v\u00eddeo <p></p> <p>Aula  Slides  C\u00f3digo </p> <p>Ap\u00f3s a cria\u00e7\u00e3o de nossos modelos e migra\u00e7\u00f5es na aula passada, chegou o momento de dar um passo significativo: integrar o banco de dados \u00e0 nossa aplica\u00e7\u00e3o FastAPI. Vamos deixar de lado o banco de dados fict\u00edcio que criamos anteriormente e mergulhar na implementa\u00e7\u00e3o de um banco de dados real e funcional.</p>"},{"location":"04/#integrando-sqlalchemy-a-nossa-aplicacao-fastapi","title":"Integrando SQLAlchemy \u00e0 Nossa Aplica\u00e7\u00e3o FastAPI","text":"<p>Para aqueles que n\u00e3o est\u00e3o familiarizados, o SQLAlchemy \u00e9 uma biblioteca Python que facilita a intera\u00e7\u00e3o com um banco de dados SQL. Ele faz isso oferecendo uma forma de trabalhar com bancos de dados que aproveita a facilidade e o poder do Python, ao mesmo tempo em que mant\u00e9m a efici\u00eancia e a flexibilidade dos bancos de dados SQL.</p> <p>Uma pe\u00e7a chave do SQLAlchemy \u00e9 o conceito de uma \"sess\u00e3o\". Se voc\u00ea \u00e9 novo no mundo dos bancos de dados, pode pensar na sess\u00e3o como um carrinho de compras virtual: conforme voc\u00ea navega pelo site (ou, neste caso, conforme seu c\u00f3digo executa), voc\u00ea pode adicionar ou remover itens desse carrinho. No entanto, nenhuma altera\u00e7\u00e3o \u00e9 realmente feita at\u00e9 que voc\u00ea decida finalizar a compra. No contexto do SQLAlchemy, \"finalizar a compra\" \u00e9 equivalente a fazer o commit das suas altera\u00e7\u00f5es.</p> <p>A sess\u00e3o no SQLAlchemy \u00e9 t\u00e3o poderosa que, na verdade, incorpora tr\u00eas padr\u00f5es de arquitetura importantes.</p> <ol> <li> <p>Mapa de Identidade: Imagine que voc\u00ea esteja comprando frutas em uma loja online. Cada fruta que voc\u00ea adiciona ao seu carrinho recebe um c\u00f3digo de barras \u00fanico, para que a loja saiba exatamente qual fruta voc\u00ea quer. O Mapa de Identidade no SQLAlchemy \u00e9 esse sistema de c\u00f3digo de barras: ele garante que cada objeto na sess\u00e3o seja \u00fanico e facilmente identific\u00e1vel.</p> </li> <li> <p>Reposit\u00f3rio: A sess\u00e3o tamb\u00e9m atua como um reposit\u00f3rio. Isso significa que ela \u00e9 como um porteiro: ela controla todas as comunica\u00e7\u00f5es entre o seu c\u00f3digo Python e o banco de dados. Todos os comandos que voc\u00ea deseja enviar para o banco de dados devem passar pela sess\u00e3o.</p> </li> <li> <p>Unidade de Trabalho: Finalmente, a sess\u00e3o age como uma unidade de trabalho. Isso significa que ela mant\u00e9m o controle de todas as altera\u00e7\u00f5es que voc\u00ea quer fazer no banco de dados. Se voc\u00ea adicionar uma fruta ao seu carrinho e depois mudar de ideia e remover, a sess\u00e3o lembrar\u00e1 de ambas as a\u00e7\u00f5es. Ent\u00e3o, quando voc\u00ea finalmente decidir finalizar a compra, ela enviar\u00e1 todas as suas altera\u00e7\u00f5es para o banco de dados de uma s\u00f3 vez.</p> </li> </ol> <p>Entender esses conceitos \u00e9 importante, pois nos ajuda a entender melhor como o SQLAlchemy funciona e como podemos us\u00e1-lo de forma mais eficaz. Agora que temos uma ideia do que \u00e9 uma sess\u00e3o, vamos configurar uma para nosso projeto.</p> <p>Para isso, criaremos a fun\u00e7\u00e3o <code>get_session</code> e tamb\u00e9m definiremos <code>Session</code> no arquivo <code>database.py</code>:</p> fast_zero/database.py<pre><code>from sqlalchemy import create_engine\nfrom sqlalchemy.orm import Session\nfrom fast_zero.settings import Settings\nengine = create_engine(Settings().DATABASE_URL)\ndef get_session():\nwith Session(engine) as session:\nyield session\n</code></pre>"},{"location":"04/#gerenciando-dependencias-com-fastapi","title":"Gerenciando Depend\u00eancias com FastAPI","text":"<p>Assim como a sess\u00e3o SQLAlchemy, que implementa v\u00e1rios padr\u00f5es arquiteturais importantes, FastAPI tamb\u00e9m usa um conceito de padr\u00e3o arquitetural chamado \"Inje\u00e7\u00e3o de Depend\u00eancia\". </p> <p>No mundo do desenvolvimento de software, uma \"depend\u00eancia\" \u00e9 um componente que um m\u00f3dulo de software precisa para realizar sua fun\u00e7\u00e3o. Imagine um m\u00f3dulo como uma f\u00e1brica e as depend\u00eancias como as partes ou mat\u00e9rias-primas que a f\u00e1brica precisa para produzir seus produtos. Em vez de a f\u00e1brica ter que buscar essas pe\u00e7as por conta pr\u00f3pria (o que seria ineficiente), elas s\u00e3o entregues \u00e0 f\u00e1brica, prontas para serem usadas. Este \u00e9 o conceito de Inje\u00e7\u00e3o de Depend\u00eancia.</p> <p>A Inje\u00e7\u00e3o de Depend\u00eancia permite que mantenhamos um baixo n\u00edvel de acoplamento entre diferentes m\u00f3dulos de um sistema. As depend\u00eancias entre os m\u00f3dulos n\u00e3o s\u00e3o definidas no c\u00f3digo, mas sim pela configura\u00e7\u00e3o de uma infraestrutura de software (container) que \u00e9 respons\u00e1vel por \"injetar\" em cada componente suas depend\u00eancias declaradas.</p> <p>Em termos pr\u00e1ticos, o que isso significa \u00e9 que, em vez de cada parte do nosso c\u00f3digo ter que criar suas pr\u00f3prias inst\u00e2ncias de classes ou servi\u00e7os de que depende (o que pode levar a duplica\u00e7\u00e3o de c\u00f3digo e tornar os testes mais dif\u00edceis), essas inst\u00e2ncias s\u00e3o criadas uma vez e depois injetadas onde s\u00e3o necess\u00e1rias.</p> <p>FastAPI fornece a fun\u00e7\u00e3o <code>Depends</code> para ajudar a declarar e gerenciar essas depend\u00eancias. \u00c9 uma maneira declarativa de dizer ao FastAPI: \"Antes de executar esta fun\u00e7\u00e3o, execute primeiro essa outra fun\u00e7\u00e3o e passe-me o resultado\". Isso \u00e9 especialmente \u00fatil quando temos opera\u00e7\u00f5es que precisam ser realizadas antes de cada request, como abrir uma sess\u00e3o de banco de dados. </p>"},{"location":"04/#modificando-o-endpoint-post-users","title":"Modificando o Endpoint POST /users","text":"<p>Agora que temos a nossa sess\u00e3o de banco de dados sendo gerenciada por meio do FastAPI e da inje\u00e7\u00e3o de depend\u00eancias, vamos atualizar nossos endpoints para que possam tirar proveito disso. Come\u00e7aremos com a rota de POST para a cria\u00e7\u00e3o de usu\u00e1rios. Ao inv\u00e9s de usarmos o banco de dados falso que criamos inicialmente, agora vamos fazer a inser\u00e7\u00e3o real dos usu\u00e1rios no nosso banco de dados.</p> <p>Para isso, vamos modificar o nosso endpoint da seguinte maneira:</p> fast_zero/app.py<pre><code>from fastapi import Depends, FastAPI, HTTPException\nfrom sqlalchemy import select\nfrom sqlalchemy.orm import Session\nfrom fast_zero.models import User\nfrom fast_zero.database import get_session\nfrom fast_zero.schemas import UserSchema, UserPublic, UserDB, UserList, Message\n# ...\n@app.post('/users/', response_model=UserPublic, status_code=201)\ndef create_user(user: UserSchema, session: Session = Depends(get_session)):\ndb_user = session.scalar(\nselect(User).where(User.username == user.username)\n)\nif db_user:\nraise HTTPException(\nstatus_code=400, detail='Username already registered'\n)\ndb_user = User(\nusername=user.username, password=user.password, email=user.email\n)\nsession.add(db_user)\nsession.commit()\nsession.refresh(db_user)\nreturn db_user\n</code></pre> <p>Nesse c\u00f3digo, a fun\u00e7\u00e3o <code>create_user</code> recebe um objeto do tipo <code>UserSchema</code> e uma sess\u00e3o SQLAlchemy, que \u00e9 injetada automaticamente pelo FastAPI usando o <code>Depends</code>. O c\u00f3digo verifica se j\u00e1 existe um usu\u00e1rio com o mesmo nome no banco de dados e, caso n\u00e3o exista, cria um novo usu\u00e1rio, adiciona-o \u00e0 sess\u00e3o e confirma a transa\u00e7\u00e3o.</p> <p>Ao executar nosso linter, ele ir\u00e1 apontar um erro informando que importamos UserDB mas nunca o usamos.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task lint\nfast_zero/app.py:7:55: F401 [*] `fast_zero.schemas.UserDB` imported but unused\nFound 1 error.\n</code></pre> <p>Isso ocorre porque a rota POST era a \u00fanica que estava utilizando UserDB, e agora que modificamos esta rota, podemos remover UserDB dos nossos imports.</p>"},{"location":"04/#testando-o-endpoint-post-users-com-pytest-e-fixtures","title":"Testando o Endpoint POST /users com Pytest e Fixtures","text":"<p>Agora que nossa rota de POST est\u00e1 funcionando com o banco de dados real, precisamos atualizar nossos testes para refletir essa mudan\u00e7a. Como estamos usando a inje\u00e7\u00e3o de depend\u00eancias, precisamos tamb\u00e9m usar essa funcionalidade nos nossos testes para que possamos injetar a sess\u00e3o de banco de dados de teste.</p> <p>Vamos criar a nossa fixture <code>client</code> para substituir a fun\u00e7\u00e3o <code>get_session</code> que estamos injetando no endpoint pela sess\u00e3o do banco em mem\u00f3ria que j\u00e1 t\u00ednhamos definido para banco de dados.</p> tests/conftest.py<pre><code>from fastapi.testclient import TestClient\nfrom fast_zero.app import app\nfrom fast_zero.database import get_session\n# ...\n@pytest.fixture\ndef client(session):\ndef get_session_override():\nreturn session\nwith TestClient(app) as client:\napp.dependency_overrides[get_session] = get_session_override\nyield client\napp.dependency_overrides.clear()\n</code></pre> <p>Com isso, quando o FastAPI tentar injetar a sess\u00e3o em nossos endpoints, ele vai injetar a sess\u00e3o de teste que definimos, em vez da sess\u00e3o real. E como estamos usando um banco de dados em mem\u00f3ria para os testes, nossos testes n\u00e3o v\u00e3o interferir nos dados reais do nosso aplicativo.</p> tests/test_app.py<pre><code>def test_create_user(client):\nresponse = client.post(\n'/users',\njson={\n'username': 'alice',\n'email': 'alice@example.com',\n'password': 'secret',\n},\n)\nassert response.status_code == 201\nassert response.json() == {\n'username': 'alice',\n'email': 'alice@example.com',\n'id': 1,\n}\n</code></pre> <p>Agora que temos a nossa fixture configurada, vamos atualizar o nosso teste <code>test_create_user</code> para usar o novo cliente de teste e verificar que o usu\u00e1rio est\u00e1 sendo realmente criado no banco de dados.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n# ...\ntests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED\ntests/test_app.py::test_create_user PASSED\ntests/test_app.py::test_read_users FAILED\n</code></pre> <p>Depois de realizar essas mudan\u00e7as, podemos executar nossos testes e verificar se est\u00e3o passando. Por\u00e9m, embora o teste <code>test_create_user</code> tenha passado, precisamos agora ajustar os outros endpoints para que eles tamb\u00e9m utilizem a nossa sess\u00e3o de banco de dados. Nos pr\u00f3ximos passos, vamos realizar essas modifica\u00e7\u00f5es para garantir que todo o nosso aplicativo esteja usando o banco de dados real.</p>"},{"location":"04/#modificando-o-endpoint-get-users","title":"Modificando o Endpoint GET /users","text":"<p>{dizer que agora vamos atualizar o nosso endpoint de GET para funcionar no modelo real do banco de dados}</p> fast_zero/app.py<pre><code>@app.get('/users/', response_model=UserList)\ndef read_users(\nskip: int = 0, limit: int = 100, session: Session = Depends(get_session)\n):\nusers = session.scalars(select(User).offset(skip).limit(limit)).all()\nreturn {'users': users}\n</code></pre> <p>{explicar o que s\u00e3o as coisas que adicionamos como <code>offset</code> e <code>limit</code> e porque elas s\u00e3o importantes agora nesses casos}</p>"},{"location":"04/#testando-o-endpoint-get-users","title":"Testando o Endpoint GET /users","text":"<p>Com a mudan\u00e7a para o banco de dados real, nosso banco de dados de teste ser\u00e1 sempre resetado para cada teste. Portanto, n\u00e3o podemos mais executar o teste que t\u00ednhamos antes, pois n\u00e3o haver\u00e3o usu\u00e1rios no banco. Para verificar se o nosso endpoint est\u00e1 funcionando corretamente, vamos criar um novo teste que solicita uma lista de usu\u00e1rios de um banco vazio:</p> tests/test_app.py<pre><code>def test_read_users(client):\nresponse = client.get('/users')\nassert response.status_code == 200\nassert response.json() == {'users': []}\n</code></pre> <p>Agora que temos nosso novo teste, podemos execut\u00e1-lo para verificar se o nosso endpoint GET est\u00e1 funcionando corretamente. Com esse novo teste, a fun\u00e7\u00e3o <code>test_read_users</code> deve passar.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n# ...\ntests/test_app.py::test_create_user PASSED\ntests/test_app.py::test_read_users PASSED\ntests/test_app.py::test_update_user FAILED\n</code></pre> <p>Por\u00e9m, \u00e9 claro, queremos tamb\u00e9m testar o caso em que existem usu\u00e1rios no banco. Para isso, vamos criar uma nova fixture que cria um usu\u00e1rio em nosso banco de dados de teste.</p>"},{"location":"04/#criando-uma-fixture-para-user","title":"Criando uma fixture para User","text":"<p>Para criar essa fixture, vamos aproveitar a nossa fixture de sess\u00e3o do SQLAlchemy, e criar um novo usu\u00e1rio dentro dela:</p> tests/conftest.py<pre><code>from fast_zero.models import Base, User\n# ...\n@pytest.fixture\ndef user(session):\nuser = User(username='Teste', email='teste@test.com', password='testtest')\nsession.add(user)\nsession.commit()\nsession.refresh(user)\nreturn user\n</code></pre> <p>Com essa fixture, sempre que precisarmos de um usu\u00e1rio em nossos testes, podemos simplesmente passar <code>user</code> como um argumento para nossos testes, e o Pytest se encarregar\u00e1 de criar um novo usu\u00e1rio para n\u00f3s.</p> <p>Agora podemos criar um novo teste para verificar se o nosso endpoint est\u00e1 retornando o usu\u00e1rio correto quando existe um usu\u00e1rio no banco:</p> tests/test_app.py<pre><code>from fast_zero.schemas import UserPublic\n# ...\ndef test_read_users_with_users(client, user):\nuser_schema = UserPublic.model_validate(user).model_dump()\nresponse = client.get('/users/')\nassert response.json() == {'users': [user_schema]}\n</code></pre> <p>Agora podemos rodar o nosso teste novamente e verificar se ele est\u00e1 passando:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n# ...\ntests/test_app.py::test_create_user PASSED\ntests/test_app.py::test_read_users PASSED\ntests/test_app.py::test_read_users_with_users FAILED\n</code></pre> <p>No entanto, mesmo que nosso c\u00f3digo pare\u00e7a correto, podemos encontrar um problema: o Pydantic n\u00e3o consegue converter diretamente nosso modelo SQLAlchemy para um modelo Pydantic. Vamos resolver isso agora.</p>"},{"location":"04/#integrando-o-schema-ao-model","title":"Integrando o Schema ao Model","text":"<p>{dizer que precisamos alterar o <code>UserPublic</code> que usamos no teste para que ele reconhe\u00e7a o ORM}</p> <p>Para resolver o problema de convers\u00e3o entre SQLAlchemy e Pydantic, precisamos atualizar o nosso esquema <code>UserPublic</code> para que ele possa reconhecer os modelos do SQLAlchemy. Para isso, vamos adicionar a <code>linha model_config = ConfigDict(from_attributes=True)</code> ao nosso esquema:</p> fast_zero/schemas.py<pre><code>from pydantic import BaseModel, EmailStr, ConfigDict\n# ...\nclass UserPublic(BaseModel):\nid: int\nusername: str\nemail: EmailStr\nmodel_config = ConfigDict(from_attributes=True)\n</code></pre> <p>Com essa mudan\u00e7a, nosso esquema Pydantic agora pode ser convertido a partir de um modelo SQLAlchemy. Agora podemos executar nosso teste novamente e verificar se ele est\u00e1 passando.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n# ...\ntests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED\ntests/test_app.py::test_create_user PASSED\ntests/test_app.py::test_read_users PASSED\ntests/test_app.py::test_read_users_with_users PASSED\ntests/test_app.py::test_update_user FAILED\n</code></pre> <p>Agora que temos nosso endpoint GET funcionando corretamente e testado, podemos seguir para o endpoint PUT, e continuar com o processo de atualiza\u00e7\u00e3o dos nossos endpoints.</p>"},{"location":"04/#modificando-o-endpoint-put-users","title":"Modificando o Endpoint PUT /users","text":"<p>Agora, vamos modificar o endpoint PUT de forma semelhante ao que fizemos com os endpoints POST e GET:</p> fast_zero/app.py<pre><code>@app.put('/users/{user_id}', response_model=UserPublic)\ndef update_user(\nuser_id: int, user: UserSchema, session: Session = Depends(get_session)\n):\ndb_user = session.scalar(select(User).where(User.id == user_id))\nif db_user is None:\nraise HTTPException(status_code=404, detail='User not found')\ndb_user.username = user.username\ndb_user.password = user.password\ndb_user.email = user.email\nsession.commit()\nsession.refresh(db_user)\nreturn db_user\n</code></pre> <p>Semelhante ao que fizemos antes, estamos injetando a sess\u00e3o do SQLAlchemy em nosso endpoint e utilizando-a para buscar o usu\u00e1rio a ser atualizado. Se o usu\u00e1rio n\u00e3o for encontrado, retornamos um erro 404.</p>"},{"location":"04/#adicionando-o-teste-do-put","title":"Adicionando o teste do PUT","text":"<p>Tamb\u00e9m precisamos adicionar um teste para o nosso novo endpoint PUT:</p> tests/test_app.py<pre><code>def test_update_user(client, user):\nresponse = client.put(\n'/users/1',\njson={\n'username': 'bob',\n'email': 'bob@example.com',\n'password': 'mynewpassword',\n},\n)\nassert response.status_code == 200\nassert response.json() == {\n'username': 'bob',\n'email': 'bob@example.com',\n'id': 1,\n}\n</code></pre>"},{"location":"04/#modificando-o-endpoint-delete-users","title":"Modificando o Endpoint DELETE /users","text":"<p>Em seguida, modificamos o endpoint DELETE da mesma maneira:</p> fast_zero/app.py<pre><code>@app.delete('/users/{user_id}', response_model=Message)\ndef delete_user(user_id: int, session: Session = Depends(get_session)):\ndb_user = session.scalar(select(User).where(User.id == user_id))\nif db_user is None:\nraise HTTPException(status_code=404, detail='User not found')\nsession.delete(db_user)\nsession.commit()\nreturn {'detail': 'User deleted'}\n</code></pre> <p>Neste caso, estamos novamente usando a sess\u00e3o do SQLAlchemy para encontrar o usu\u00e1rio a ser deletado e, em seguida, exclu\u00edmos esse usu\u00e1rio do banco de dados.</p>"},{"location":"04/#adicionando-testes-para-delete","title":"Adicionando testes para DELETE","text":"<p>Assim como para o endpoint PUT, precisamos adicionar um teste para o nosso endpoint DELETE:</p> tests/test_app.py<pre><code>def test_delete_user(client, user):\nresponse = client.delete('/users/1')\nassert response.status_code == 200\nassert response.json() == {'detail': 'User deleted'}\n</code></pre>"},{"location":"04/#cobertura-e-testes-nao-feitos","title":"Cobertura e testes n\u00e3o feitos","text":"<p>Com o banco de dados agora em funcionamento, podemos verificar a cobertura de c\u00f3digo do arquivo <code>fast_zero/app.py</code>. Se olharmos para a imagem abaixo, vemos que ainda h\u00e1 alguns casos que n\u00e3o testamos. Por exemplo, o que acontece quando tentamos atualizar ou excluir um usu\u00e1rio que n\u00e3o existe?</p> <p></p> <p>Esses tr\u00eas casos ficam como exerc\u00edcio para quem est\u00e1 acompanhando este curso. </p> <p>Al\u00e9m disso, n\u00e3o devemos esquecer de remover a implementa\u00e7\u00e3o do banco de dados falso <code>database = []</code> que usamos inicialmente e remover tamb\u00e9m as defini\u00e7\u00f5es de <code>TestClient</code> em <code>test_app.py</code> pois tudo est\u00e1 usando as fixtures agora!</p>"},{"location":"04/#commit","title":"Commit","text":"<p>Agora que terminamos a atualiza\u00e7\u00e3o dos nossos endpoints, vamos fazer o commit das nossas altera\u00e7\u00f5es. O processo \u00e9 o seguinte:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git add .\ngit commit -m \"Atualizando endpoints para usar o banco de dados real\"\ngit push\n</code></pre> <p>Com isso, terminamos a atualiza\u00e7\u00e3o dos nossos endpoints para usar o nosso banco de dados real.</p>"},{"location":"04/#conclusao","title":"Conclus\u00e3o","text":"<p>Parab\u00e9ns por chegar ao final desta aula! Voc\u00ea deu um passo significativo no desenvolvimento de nossa aplica\u00e7\u00e3o, substituindo a implementa\u00e7\u00e3o do banco de dados falso pela integra\u00e7\u00e3o com um banco de dados real usando SQLAlchemy. Tamb\u00e9m vimos como ajustar os nossos testes para considerar essa nova realidade.</p> <p>Nesta aula, abordamos como modificar os endpoints para interagir com o banco de dados real e como utilizar a inje\u00e7\u00e3o de depend\u00eancias do FastAPI para gerenciar nossas sess\u00f5es do SQLAlchemy. Tamb\u00e9m discutimos a import\u00e2ncia dos testes para garantir que nossos endpoints est\u00e3o funcionando corretamente, e como as fixtures do Pytest podem nos auxiliar na prepara\u00e7\u00e3o do ambiente para esses testes.</p> <p>Tamb\u00e9m nos deparamos com situa\u00e7\u00f5es onde o Pydantic e o SQLAlchemy n\u00e3o interagem perfeitamente bem, e como solucionar esses casos.</p> <p>No final desta aula, voc\u00ea deve estar confort\u00e1vel em integrar um banco de dados real a uma aplica\u00e7\u00e3o FastAPI, saber como escrever testes robustos que levem em considera\u00e7\u00e3o a intera\u00e7\u00e3o com o banco de dados, e estar ciente de poss\u00edveis desafios ao trabalhar com Pydantic e SQLAlchemy juntos.</p>"},{"location":"05/","title":"[OK] Autentica\u00e7\u00e3o e Autoriza\u00e7\u00e3o com JWT","text":""},{"location":"05/#ok-autenticacao-e-autorizacao-com-jwt","title":"[OK] Autentica\u00e7\u00e3o e Autoriza\u00e7\u00e3o com JWT","text":"<p>Objetivos da Aula:</p> <ul> <li>Implementar autentica\u00e7\u00e3o de usu\u00e1rios com JWT.</li> <li>Adicionar l\u00f3gica de autoriza\u00e7\u00e3o aos endpoints de atualiza\u00e7\u00e3o e dele\u00e7\u00e3o.</li> <li>Utilizar a biblioteca Bcrypt para encriptar as senhas dos usu\u00e1rios.</li> </ul> Caso prefira ver a aula em v\u00eddeo <p></p> <p>Aula  Slides  C\u00f3digo </p>"},{"location":"05/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>Nesta aula, vamos abordar dois aspectos cruciais de qualquer aplica\u00e7\u00e3o web: a autentica\u00e7\u00e3o e a autoriza\u00e7\u00e3o. At\u00e9 agora, nossos usu\u00e1rios podem criar, ler, atualizar e deletar suas contas, mas qualquer pessoa pode fazer essas a\u00e7\u00f5es. N\u00e3o queremos que qualquer usu\u00e1rio possa deletar ou modificar a conta de outro usu\u00e1rio. Para evitar isso, vamos implementar autentica\u00e7\u00e3o e autoriza\u00e7\u00e3o em nossa aplica\u00e7\u00e3o.</p> <p>A autentica\u00e7\u00e3o \u00e9 o processo de verificar quem um usu\u00e1rio \u00e9, enquanto a autoriza\u00e7\u00e3o \u00e9 o processo de verificar o que ele tem permiss\u00e3o para fazer. Usaremos o JSON Web Token (JWT) para implementar a autentica\u00e7\u00e3o, e adicionaremos l\u00f3gica de autoriza\u00e7\u00e3o aos nossos endpoints.</p> <p>Al\u00e9m disso, at\u00e9 agora, estamos armazenando as senhas dos usu\u00e1rios como texto puro no banco de dados, o que \u00e9 uma pr\u00e1tica insegura. Vamos corrigir isso utilizando a biblioteca Bcrypt para encriptar as senhas.</p>"},{"location":"05/#o-que-e-um-jwt","title":"O que \u00e9 um JWT","text":"<p>Um JWT consiste em tr\u00eas partes:</p> <ol> <li>Header: cont\u00e9m o tipo de token (JWT) e o algoritmo de assinatura usado.</li> <li>Payload: cont\u00e9m as reivindica\u00e7\u00f5es, que s\u00e3o informa\u00e7\u00f5es sobre o usu\u00e1rio (como o ID do usu\u00e1rio) e outras informa\u00e7\u00f5es adicionais.</li> <li>Signature: usada para verificar que o remetente do token \u00e9 quem diz ser e para garantir que a mensagem n\u00e3o foi alterada ao longo do caminho.</li> </ol> <p>Essas tr\u00eas partes s\u00e3o separadas por pontos (.) e juntas formam um token JWT.</p>"},{"location":"05/#como-funciona-o-jwt","title":"Como funciona o JWT","text":"<p>Em uma aplica\u00e7\u00e3o web, o processo de autentica\u00e7\u00e3o geralmente funciona da seguinte maneira:</p> <ol> <li>O usu\u00e1rio envia suas credenciais (nome de usu\u00e1rio e senha) para o servidor.</li> <li>O servidor verifica as credenciais e, se estiverem corretas, gera um token JWT e o envia de volta ao cliente.</li> <li>Nas solicita\u00e7\u00f5es subsequentes, o cliente deve incluir esse token no cabe\u00e7alho de autoriza\u00e7\u00e3o de suas solicita\u00e7\u00f5es.</li> <li>Quando o servidor recebe uma solicita\u00e7\u00e3o com um token JWT, ele pode verificar a assinatura e se o token \u00e9 v\u00e1lido e n\u00e3o expirou, ele processa a solicita\u00e7\u00e3o.</li> </ol> <pre><code>sequenceDiagram\n  participant Cliente as Cliente\n  participant Servidor as Servidor\n  Cliente-&gt;&gt;Servidor: Envia credenciais (nome de usu\u00e1rio e senha)\n  Servidor-&gt;&gt;Cliente: Verifica as credenciais\n  Servidor-&gt;&gt;Cliente: Envia token JWT\n  Cliente-&gt;&gt;Servidor: Envia solicita\u00e7\u00e3o com token JWT no cabe\u00e7alho de autoriza\u00e7\u00e3o\n  Servidor-&gt;&gt;Cliente: Verifica o token JWT e processa a solicita\u00e7\u00e3o</code></pre> <p>Nos pr\u00f3ximos t\u00f3picos, vamos detalhar como podemos gerar e verificar tokens JWT em nossa aplica\u00e7\u00e3o FastAPI, bem como adicionar autentica\u00e7\u00e3o e autoriza\u00e7\u00e3o aos nossos endpoints.</p>"},{"location":"05/#gerando-tokens-jwt","title":"Gerando tokens JWT","text":"<p>Para gerar tokens JWT, precisamos de duas bibliotecas extras: <code>python-jose</code> e <code>passlib</code>. A primeira ser\u00e1 usada para a gera\u00e7\u00e3o do token, enquanto a segunda ser\u00e1 usada para criptografar as senhas dos usu\u00e1rios. Para instal\u00e1-las, execute o seguinte comando no terminal:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry add python-jose[cryptography] passlib[bcrypt]\n</code></pre> <p>Agora, vamos criar uma fun\u00e7\u00e3o para gerar nossos tokens JWT. Vamos criar um novo arquivo para gerenciar a seguran\u00e7a <code>security.py</code>. Nesse arquivo vamos iniciar a gera\u00e7\u00e3o dos tokens:</p> fast_zero/security.py<pre><code>from datetime import datetime, timedelta\nfrom jose import jwt\nfrom passlib.context import CryptContext\nSECRET_KEY = 'your-secret-key'  # Isso \u00e9 privis\u00f3rio, vamos ajustar!\nALGORITHM = 'HS256'\nACCESS_TOKEN_EXPIRE_MINUTES = 30\npwd_context = CryptContext(schemes=['bcrypt'], deprecated='auto')\ndef create_access_token(data: dict):\nto_encode = data.copy()\nexpire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\nto_encode.update({'exp': expire})\nencoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\nreturn encoded_jwt\n</code></pre> <p>A fun\u00e7\u00e3o <code>create_access_token</code> \u00e9 respons\u00e1vel por criar um novo token JWT que ser\u00e1 usado para autenticar o usu\u00e1rio. Ela recebe um dicion\u00e1rio de dados, adiciona um tempo de expira\u00e7\u00e3o ao token (baseado na constante <code>ACCESS_TOKEN_EXPIRE_MINUTES</code>), e em seguida usa a biblioteca <code>jose</code> para codificar essas informa\u00e7\u00f5es em um token JWT, que \u00e9 ent\u00e3o retornado.</p> <p>Note que a constante <code>SECRET_KEY</code> \u00e9 usada para assinar o token, e o algoritmo <code>HS256</code> \u00e9 usado para a codifica\u00e7\u00e3o. Em um cen\u00e1rio de produ\u00e7\u00e3o, voc\u00ea deve manter a <code>SECRET_KEY</code> em um local seguro e n\u00e3o exp\u00f4-la em seu c\u00f3digo.</p> <p>Na pr\u00f3xima se\u00e7\u00e3o, vamos ver como podemos usar a biblioteca <code>passlib</code> para tratar as senhas dos usu\u00e1rios.</p>"},{"location":"05/#hashing-de-senhas","title":"Hashing de Senhas","text":"<p>Armazenar senhas em texto puro \u00e9 uma pr\u00e1tica de seguran\u00e7a extremamente perigosa. Em vez disso, \u00e9 uma pr\u00e1tica padr\u00e3o criptografar (\"hash\") as senhas antes de armazen\u00e1-las. Quando um usu\u00e1rio tenta se autenticar, a senha inserida \u00e9 criptografada novamente e comparada com a vers\u00e3o criptografada armazenada no banco de dados. Se as duas correspondem, o usu\u00e1rio \u00e9 autenticado.</p> <p>Vamos implementar essa funcionalidade usando a biblioteca <code>passlib</code>. Vamos criar duas fun\u00e7\u00f5es: uma para criar o hash da senha e outra para verificar se uma senha inserida corresponde ao hash armazenado. Adicione o seguinte c\u00f3digo ao arquivo <code>security.py</code>:</p> fast_zero/security.py<pre><code>def get_password_hash(password: str):\nreturn pwd_context.hash(password)\ndef verify_password(plain_password: str, hashed_password: str):\nreturn pwd_context.verify(plain_password, hashed_password)\n</code></pre> <p>A fun\u00e7\u00e3o <code>get_password_hash</code> recebe uma senha em texto puro como argumento e retorna uma vers\u00e3o criptografada dessa senha. A fun\u00e7\u00e3o <code>verify_password</code> recebe uma senha em texto puro e uma senha criptografada como argumentos, e verifica se a senha em texto puro, quando criptografada, corresponde \u00e0 senha criptografada. Ambas as fun\u00e7\u00f5es utilizam o objeto <code>pwd_context</code>, que definimos anteriormente usando a biblioteca <code>passlib</code>.</p> <p>Agora, quando um usu\u00e1rio se registra em nossa aplica\u00e7\u00e3o, devemos usar a fun\u00e7\u00e3o <code>get_password_hash</code> para armazenar uma vers\u00e3o criptografada da senha. Quando um usu\u00e1rio tenta se autenticar, devemos usar a fun\u00e7\u00e3o <code>verify_password</code> para verificar se a senha inserida corresponde \u00e0 senha armazenada.</p> <p>Na pr\u00f3xima se\u00e7\u00e3o, vamos modificar nossos endpoints para fazer uso dessas fun\u00e7\u00f5es.</p>"},{"location":"05/#modificando-os-endpoints-para-usar-a-autenticacao","title":"Modificando os Endpoints para Usar a Autentica\u00e7\u00e3o","text":"<p>Com as fun\u00e7\u00f5es de cria\u00e7\u00e3o de hash de senha e verifica\u00e7\u00e3o de senha em vigor, agora podemos atualizar nossos endpoints para usar essa nova funcionalidade de autentica\u00e7\u00e3o.</p> <p>Primeiro, vamos modificar a fun\u00e7\u00e3o <code>create_user</code> para criar um hash da senha antes de armazen\u00e1-la no banco de dados.</p> fast_zero/app.py<pre><code>from fast_zero.security import get_password_hash\n# ...\n@app.post('/users/', response_model=UserPublic, status_code=201)\ndef create_user(user: UserSchema, session: Session = Depends(get_session)):\ndb_user = session.scalar(select(User).where(User.email == user.email))\nif db_user:\nraise HTTPException(status_code=400, detail='Email already registered')\nhashed_password = get_password_hash(user.password)\ndb_user = User(\nemail=user.email,\nusername=user.username,\npassword=hashed_password,\n)\nsession.add(db_user)\nsession.commit()\nsession.refresh(db_user)\nreturn db_user\n</code></pre> <p>Nesse novo c\u00f3digo, estamos usando a fun\u00e7\u00e3o <code>get_password_hash</code> para criar um hash da senha antes de armazen\u00e1-la no banco de dados. Al\u00e9m disso, estamos armazenando o hash da senha, em vez da senha em texto plano, em nosso objeto <code>User</code>.</p>"},{"location":"05/#sobre-o-teste-da-post-users","title":"Sobre o teste da POST /users/","text":"<p>Por n\u00e3o validar o password, usando o retorno <code>UserPublic</code>, o teste j\u00e1 escrito deve passar normalmente:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n# ...\ntests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED\ntests/test_app.py::test_create_user PASSED\n</code></pre>"},{"location":"05/#criando-um-endpoint-de-geracao-do-token","title":"Criando um endpoint de gera\u00e7\u00e3o do token","text":"<p>Antes de criar o endpoint, precisamos criar um schema para o nosso token. Em um contexto JWT, <code>access_token</code> \u00e9 o pr\u00f3prio token que representa a sess\u00e3o do usu\u00e1rio e cont\u00e9m informa\u00e7\u00f5es sobre o usu\u00e1rio, enquanto <code>token_type</code> \u00e9 um tipo de autentica\u00e7\u00e3o que ser\u00e1 inclu\u00eddo no cabe\u00e7alho de autoriza\u00e7\u00e3o de cada solicita\u00e7\u00e3o. Em geral, o <code>token_type</code> para JWT \u00e9 \"bearer\".</p> fast_zero/schemas.py<pre><code>class Token(BaseModel):\naccess_token: str\ntoken_type: str\n</code></pre>"},{"location":"05/#utilizando-oauth2passwordrequestform","title":"Utilizando OAuth2PasswordRequestForm","text":"<p>A classe <code>OAuth2PasswordRequestForm</code> \u00e9 uma classe especial do FastAPI que gera automaticamente um formul\u00e1rio para solicitar o username (email neste caso) e a senha. Este formul\u00e1rio ser\u00e1 apresentado automaticamente no Swagger UI e Redoc, o que facilita a realiza\u00e7\u00e3o de testes de autentica\u00e7\u00e3o.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry add python-multipart\n</code></pre>"},{"location":"05/#criando-um-endpoint-de-geracao-do-token_1","title":"Criando um endpoint de gera\u00e7\u00e3o do token","text":"<p>Agora vamos criar o endpoint que ir\u00e1 autenticar o usu\u00e1rio e fornecer um token de acesso JWT. Este endpoint ir\u00e1 receber as informa\u00e7\u00f5es de login do usu\u00e1rio, verificar se as credenciais s\u00e3o v\u00e1lidas e, em caso afirmativo, retornar um token de acesso JWT.</p> fast_zero/app.py<pre><code>from fastapi.security import OAuth2PasswordRequestForm\nfrom fast_zero.schemas import Message, Token, UserList, UserPublic, UserSchema\nfrom fast_zero.security import (\ncreate_access_token,\nget_password_hash,\nverify_password,\n)\n# ...\n@app.post('/token', response_model=Token)\ndef login_for_access_token(\nform_data: OAuth2PasswordRequestForm = Depends(),\nsession: Session = Depends(get_session),\n):\nuser = session.scalar(select(User).where(User.email == form_data.username))\nif not user:\nraise HTTPException(\nstatus_code=400, detail='Incorrect email or password'\n)\nif not verify_password(form_data.password, user.password):\nraise HTTPException(\nstatus_code=400, detail='Incorrect email or password'\n)\naccess_token = create_access_token(data={'sub': user.email})\nreturn {'access_token': access_token, 'token_type': 'bearer'}\n</code></pre> <p>Esse endpoint recebe os dados do formul\u00e1rio atrav\u00e9s do <code>form_data</code> (que s\u00e3o injetados automaticamente gra\u00e7as ao <code>Depends()</code>) e tenta recuperar um usu\u00e1rio com o email fornecido. Se o usu\u00e1rio n\u00e3o for encontrado ou a senha n\u00e3o corresponder ao hash armazenado no banco de dados, uma exce\u00e7\u00e3o \u00e9 lan\u00e7ada. Caso contr\u00e1rio, um token de acesso \u00e9 criado usando o <code>create_access_token()</code> que criamos anteriormente e retornado como uma resposta.</p>"},{"location":"05/#testando-token","title":"Testando /token","text":"<p>Agora vamos escrever um teste para verificar se o nosso novo endpoint est\u00e1 funcionando corretamente.</p> tests/test_app.py<pre><code>def test_get_token(client, user):\nresponse = client.post(\n'/token',\ndata={'username': user.email, 'password': user.password},\n)\ntoken = response.json()\nassert response.status_code == 200\nassert 'access_token' in token\nassert 'token_type' in token\n</code></pre> <p>Nesse teste, n\u00f3s enviamos uma requisi\u00e7\u00e3o POST para o endpoint \"/token\" com um username e uma senha v\u00e1lidos. Ent\u00e3o, n\u00f3s verificamos que a resposta cont\u00e9m um \"access_token\" e um \"token_type\", que s\u00e3o os campos que esperamos de um JWT v\u00e1lido.</p> <p>No entanto, h\u00e1 um problema. Agora que a senha est\u00e1 sendo criptografada, nosso teste falhar\u00e1:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n# ...\ntests/test_app.py::test_get_token FAILED\n</code></pre> <p>Para corrigir isso, precisamos garantir que a senha esteja sendo criptografada na fixture antes de ser salva:</p> tests/confitest.py<pre><code>from fast_zero.security import get_password_hash\n# ...\n@pytest.fixture\ndef user(session):\nuser = User(\nusername='Teste',\nemail='teste@test.com',\npassword=get_password_hash('testtest'),\n)\nsession.add(user)\nsession.commit()\nsession.refresh(user)\nreturn user\n</code></pre> <p>Vamos rodar o teste novamente. No entanto, ainda teremos um problema. Agora s\u00f3 temos a vers\u00e3o criptografada da senha, que n\u00e3o \u00e9 \u00fatil para fazer o login, j\u00e1 que o login exige a senha em texto puro:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n# ...\ntests/test_app.py::test_get_token FAILED\n</code></pre> <p>Para resolver isso, faremos uma modifica\u00e7\u00e3o no objeto user (um monkey patch) para adicionar a senha em texto puro:</p> tests/confitest.py<pre><code>@pytest.fixture\ndef user(session):\npassword = 'testtest'\nuser = User(\nusername='Teste',\nemail='teste@test.com',\npassword=get_password_hash(password),\n)\nsession.add(user)\nsession.commit()\nsession.refresh(user)\nuser.clean_password = 'testtest'\nreturn user\n</code></pre> <p>Monkey patching \u00e9 uma t\u00e9cnica em que modificamos ou estendemos o c\u00f3digo em tempo de execu\u00e7\u00e3o. Neste caso, estamos adicionando um novo atributo <code>clean_password</code> ao objeto user para armazenar a senha em texto puro.</p> <p>Agora, podemos alterar o teste para usar <code>clean_password</code>:</p> tests/test_app.py<pre><code>def test_get_token(client, user):\nresponse = client.post(\n'/token',\ndata={'username': user.email, 'password': user.clean_password},\n)\ntoken = response.json()\nassert response.status_code == 200\nassert 'access_token' in token\nassert 'token_type' in token\n</code></pre> <p>E agora todos os testes devem passar normalmente:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n# ...\ntests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED\ntests/test_app.py::test_create_user PASSED\ntests/test_app.py::test_read_users PASSED\ntests/test_app.py::test_read_users_with_users PASSED\ntests/test_app.py::test_update_user PASSED\ntests/test_app.py::test_delete_user PASSED\ntests/test_app.py::test_get_token PASSED\ntests/test_db.py::test_create_user PASSED\n</code></pre> <p>Isso conclui a parte de autentica\u00e7\u00e3o de nossa API. No pr\u00f3ximo passo, iremos implementar a autoriza\u00e7\u00e3o nos endpoints.</p>"},{"location":"05/#protegendo-os-endpoints","title":"Protegendo os Endpoints","text":"<p>Agora que temos uma forma de autenticar nossos usu\u00e1rios e emitir tokens JWT, \u00e9 hora de usar essa infraestrutura para proteger nossos endpoints. Neste passo, vamos adicionar autentica\u00e7\u00e3o aos endpoints PUT e DELETE.</p> <p>Para garantir que as informa\u00e7\u00f5es do usu\u00e1rio sejam extra\u00eddas corretamente do token JWT, precisamos de um schema especial, o <code>TokenData</code>. Esse schema ser\u00e1 utilizado para tipificar os dados extra\u00eddos do token JWT e garantir que temos um campo <code>username</code> que ser\u00e1 usado para identificar o usu\u00e1rio.</p> fast_zero/schemas.py<pre><code>class TokenData(BaseModel):\nusername: str | None = None\n</code></pre> <p>Nesse ponto, criaremos uma a fun\u00e7\u00e3o <code>get_current_user</code> que ser\u00e1 respons\u00e1vel por extrair o token JWT do header <code>Authorization</code> da requisi\u00e7\u00e3o, decodificar esse token, extrair as informa\u00e7\u00f5es do usu\u00e1rio e finalmente obter o usu\u00e1rio do banco de dados. Se qualquer um desses passos falhar, uma exce\u00e7\u00e3o ser\u00e1 lan\u00e7ada e a requisi\u00e7\u00e3o ser\u00e1 negada. Vamos cria-l\u00e1 no arquivo <code>security.py</code>:</p> fast_zero/security.py<pre><code>from datetime import datetime, timedelta\nfrom fastapi import Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jose import JWTError, jwt\nfrom passlib.context import CryptContext\nfrom sqlalchemy import select\nfrom sqlalchemy.orm import Session\nfrom fast_zero.database import get_session\nfrom fast_zero.models import User\nfrom fast_zero.schemas import TokenData\n# ...\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\nasync def get_current_user(\nsession: Session = Depends(get_session),\ntoken: str = Depends(oauth2_scheme),\n):\ncredentials_exception = HTTPException(\nstatus_code=status.HTTP_401_UNAUTHORIZED,\ndetail='Could not validate credentials',\nheaders={'WWW-Authenticate': 'Bearer'},\n)\ntry:\npayload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\nusername: str = payload.get('sub')\nif not username:\nraise credentials_exception\ntoken_data = TokenData(username=username)\nexcept JWTError:\nraise credentials_exception\nuser = session.scalar(\nselect(User).where(User.email == token_data.username)\n)\nif user is None:\nraise credentials_exception\nreturn user\n</code></pre> <p>Primeiro, vamos aplicar a autentica\u00e7\u00e3o no endpoint PUT. Se o <code>user_id</code> da rota n\u00e3o corresponder ao <code>id</code> do usu\u00e1rio autenticado, retornaremos um erro 400. Se tudo estiver correto, o usu\u00e1rio ser\u00e1 atualizado normalmente.</p> fast_zero/app.py<pre><code>from fast_zero.security import (\ncreate_access_token,\nget_current_user,\nget_password_hash,\nverify_password,\n)\n# ...\n@app.put('/users/{user_id}', response_model=UserPublic)\ndef update_user(\nuser_id: int,\nuser: UserSchema,\nsession: Session = Depends(get_session),\ncurrent_user: User = Depends(get_current_user),\n):\nif current_user.id != user_id:\nraise HTTPException(status_code=400, detail='Not enough permissions')\ndb_user = session.scalar(select(User).where(User.id == user_id))\nif db_user is None:\nraise HTTPException(status_code=404, detail='User not found')\ndb_user.username = user.username\ndb_user.password = user.password\ndb_user.email = user.email\nsession.commit()\nsession.refresh(db_user)\nreturn db_user\n</code></pre> <p>Agora, vamos aplicar a autentica\u00e7\u00e3o no endpoint DELETE. Semelhante ao PUT, se o <code>user_id</code> da rota n\u00e3o corresponder ao <code>id</code> do usu\u00e1rio autenticado, retornaremos um erro 400. Se tudo estiver correto, o usu\u00e1rio ser\u00e1 deletado.</p> fast_zero/app.py<pre><code>@app.delete('/users/{user_id}', response_model=Message)\ndef delete_user(\nuser_id: int,\nsession: Session = Depends(get_session),\ncurrent_user: User = Depends(get_current_user),\n):\nif current_user.id != user_id:\nraise HTTPException(status_code=400, detail='Not enough permissions')\ndb_user = session.scalar(select(User).where(User.id == user_id))\nif db_user is None:\nraise HTTPException(status_code=404, detail='User not found')\nsession.delete(db_user)\nsession.commit()\nreturn {'detail': 'User deleted'}\n</code></pre> <p>Com essa nova depend\u00eancia, o FastAPI automaticamente garantir\u00e1 que um token de autentica\u00e7\u00e3o v\u00e1lido seja fornecido antes de permitir o acesso a esses endpoints. Se o token n\u00e3o for v\u00e1lido, ou se o usu\u00e1rio tentar modificar ou deletar um usu\u00e1rio diferente, um erro ser\u00e1 retornado.</p>"},{"location":"05/#atualizando-os-testes","title":"Atualizando os Testes","text":"<p>Os testes precisam ser atualizados para refletir essas mudan\u00e7as. Primeiro, precisamos criar uma nova fixture que gere um token para um usu\u00e1rio de teste.</p> tests/conftest.py<pre><code>@pytest.fixture\ndef token(client, user):\nresponse = client.post(\n'/token',\ndata={'username': user.email, 'password': user.clean_password},\n)\nreturn response.json()['access_token']\n</code></pre> <p>Agora, podemos atualizar os testes para o endpoint PUT e DELETE para incluir a autentica\u00e7\u00e3o.</p> tests/test_app.py<pre><code>def test_update_user(client, user, token):\nresponse = client.put(\nf'/users/{user.id}',\nheaders={'Authorization': f'Bearer {token}'},\njson={\n'username': 'bob',\n'email': 'bob@example.com',\n'password': 'mynewpassword',\n},\n)\nassert response.status_code == 200\nassert response.json() == {\n'username': 'bob',\n'email': 'bob@example.com',\n'id': 1,\n}\ndef test_delete_user(client, user, token):\nresponse = client.delete(\nf'/users/{user.id}',\nheaders={'Authorization': f'Bearer {token}'},\n)\nassert response.status_code == 200\nassert response.json() == {'detail': 'User deleted'}\n</code></pre> <p>Finalmente, podemos rodar todos os testes para garantir que tudo esteja funcionando corretamente.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n# ...\ntests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED\ntests/test_app.py::test_create_user PASSED\ntests/test_app.py::test_read_users PASSED\ntests/test_app.py::test_read_users_with_users PASSED\ntests/test_app.py::test_update_user PASSED\ntests/test_app.py::test_delete_user PASSED\ntests/test_app.py::test_get_token PASSED\ntests/test_db.py::test_create_user PASSED\n</code></pre> <p>Com essas altera\u00e7\u00f5es, nossos endpoints agora est\u00e3o seguramente protegidos pela autentica\u00e7\u00e3o. Apenas os usu\u00e1rios autenticados podem alterar ou deletar seus pr\u00f3prios dados. Isso traz uma camada adicional de seguran\u00e7a e integridade para o nosso aplicativo.</p>"},{"location":"05/#commit","title":"Commit","text":"<p>Depois de finalizar a prote\u00e7\u00e3o dos endpoints e atualizar os testes, \u00e9 hora de fazer commit das altera\u00e7\u00f5es. N\u00e3o se esque\u00e7a de revisar as altera\u00e7\u00f5es antes de fazer o commit.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git status\ngit add .\ngit commit -m \"Protege os endpoints PUT e DELETE com autentica\u00e7\u00e3o\"\n</code></pre>"},{"location":"05/#conclusao","title":"Conclus\u00e3o","text":"<p>Nesta aula, demos um passo importante para aumentar a seguran\u00e7a da nossa API. Implementamos a autentica\u00e7\u00e3o e a autoriza\u00e7\u00e3o para os endpoints PUT e DELETE, garantindo que apenas usu\u00e1rios autenticados possam alterar ou excluir seus pr\u00f3prios dados. Tamb\u00e9m atualizamos os testes para incluir a autentica\u00e7\u00e3o. Na pr\u00f3xima aula, continuaremos a expandir a funcionalidade da nossa API. At\u00e9 l\u00e1!</p>"},{"location":"06/","title":"[OK] Refatorando a Estrutura do Projeto","text":""},{"location":"06/#ok-refatorando-a-estrutura-do-projeto","title":"[OK] Refatorando a Estrutura do Projeto","text":"<p>Objetivos da Aula:</p> <ul> <li>Reestruturar o projeto para facilitar sua manuten\u00e7\u00e3o</li> <li>Mover coisas de altentica\u00e7\u00e3o para um arquivo chamado <code>fast_zero/auth.py</code></li> <li>Deixando em <code>fast_zero/secutiry.py</code> somente as valida\u00e7\u00f5es de senha</li> <li>Remover constantes usados em c\u00f3digo (<code>SECRET_KEY</code>, <code>ALGORITHM</code> e <code>ACCESS_TOKEN_EXPIRE_MINUTES</code>) usando a classe Settings do arquivo <code>fast_zero/settings/py</code> que j\u00e1 temos e movendo para vari\u00e1veis de ambiente no arquivo <code>.env</code></li> <li>Criar um router espec\u00edfico para as rotas de <code>/users/</code></li> </ul> Caso prefira ver a aula em v\u00eddeo <p></p> <p>Aula  Slides  C\u00f3digo </p> <p>Ao longo da evolu\u00e7\u00e3o de um projeto, \u00e9 natural que sua estrutura inicial necessite de ajustes para manter a legibilidade, a facilidade de manuten\u00e7\u00e3o e a organiza\u00e7\u00e3o do c\u00f3digo. Nesta aula, faremos exatamente isso em nosso projeto FastAPI: vamos refatorar partes dele para melhorar sua estrutura e, em seguida, ampliar a cobertura de nossos testes para garantir que todos os cen\u00e1rios poss\u00edveis sejam tratados corretamente. Vamos come\u00e7ar!</p>"},{"location":"06/#criando-um-router","title":"Criando um Router","text":"<p>O FastAPI nos fornece um recurso \u00fatil chamado routers, que nos permite organizar e agrupar diferentes rotas em nossa aplica\u00e7\u00e3o. Em outras palavras, um router \u00e9 um \"subaplicativo\" FastAPI que pode ser montado em uma aplica\u00e7\u00e3o principal.</p> <p>Ao usar routers, podemos manter nosso c\u00f3digo mais organizado e leg\u00edvel, especialmente \u00e0 medida que nossa aplica\u00e7\u00e3o cresce e adicionamos mais rotas.</p> <p>Vamos come\u00e7ar criando uma nova estrutura de diret\u00f3rios dentro de fast_zero chamada <code>routes</code>, onde teremos um arquivo <code>users.py</code> que ser\u00e1 respons\u00e1vel por todas as rotas relacionadas a usu\u00e1rios. Isso nos ajudar\u00e1 a manter o c\u00f3digo relacionado aos usu\u00e1rios centralizado em um \u00fanico lugar.</p>"},{"location":"06/#criando-um-router-para-users","title":"Criando um router para Users","text":"fast_zero/routes/users.py<pre><code>from fastapi import APIRouter, Depends, HTTPException\nfrom sqlalchemy import select\nfrom sqlalchemy.orm import Session\nfrom fast_zero.database import get_session\nfrom fast_zero.models import User\nfrom fast_zero.schemas import Message, UserList, UserPublic, UserSchema\nfrom fast_zero.security import (\nget_current_user,\nget_password_hash,\n)\nrouter = APIRouter(prefix='/users')\n</code></pre> <p>Neste bloco de c\u00f3digo, criamos uma inst\u00e2ncia do APIRouter com o prefixo '/users'. Isso nos permitir\u00e1 definir as rotas relacionadas aos usu\u00e1rios neste router, em vez de no aplicativo principal. Agora, ao inv\u00e9s de usarmos @app, usaremos @router para definir nossas rotas.</p> fast_zero/routes/users.py<pre><code>@router.post('/', response_model=UserPublic, status_code=201)\n@router.get('/', response_model=UserList)\n@router.put('/{user_id}', response_model=UserPublic)\n@router.delete('/{user_id}', response_model=Message)\n</code></pre> <p>Gra\u00e7as ao uso do prefixo no router, podemos simplificar os paths de nossos endpoints. Por exemplo, em vez de definir o path como '/users/{user_id}', podemos simplesmente usar '/{user_id}'.</p> Exemplo do arquivo <code>fast_zero/routes/users.py</code> completo fast_zero/routes/users.py<pre><code>from fastapi import APIRouter, Depends, HTTPException\nfrom sqlalchemy import select\nfrom sqlalchemy.orm import Session\nfrom fast_zero.database import get_session\nfrom fast_zero.models import User\nfrom fast_zero.schemas import Message, UserList, UserPublic, UserSchema\nfrom fast_zero.security import (\nget_current_user,\nget_password_hash,\n)\nrouter = APIRouter(prefix='/users')\n@router.post('/', response_model=UserPublic, status_code=201)\ndef create_user(user: UserSchema, session: Session = Depends(get_session)):\ndb_user = session.scalar(select(User).where(User.email == user.email))\nif db_user:\nraise HTTPException(status_code=400, detail='Email already registered')\nhashed_password = get_password_hash(user.password)\ndb_user = User(\nemail=user.email,\nusername=user.username,\npassword=hashed_password,\n)\nsession.add(db_user)\nsession.commit()\nsession.refresh(db_user)\nreturn db_user\n@router.get('/', response_model=UserList)\ndef read_users(\nskip: int = 0, limit: int = 100, session: Session = Depends(get_session)\n):\nusers = session.scalars(select(User).offset(skip).limit(limit)).all()\nreturn {'users': users}\n@router.put('/{user_id}', response_model=UserPublic)\ndef update_user(\nuser_id: int,\nuser: UserSchema,\nsession: Session = Depends(get_session),\ncurrent_user: User = Depends(get_current_user),\n):\nif current_user.id != user_id:\nraise HTTPException(status_code=400, detail='Not enough permissions')\ndb_user = session.scalar(select(User).where(User.id == user_id))\nif db_user is None:\nraise HTTPException(status_code=404, detail='User not found')\ndb_user.username = user.username\ndb_user.password = user.password\ndb_user.email = user.email\nsession.commit()\nsession.refresh(db_user)\nreturn db_user\n@router.delete('/{user_id}', response_model=Message)\ndef delete_user(\nuser_id: int,\nsession: Session = Depends(get_session),\ncurrent_user: User = Depends(get_current_user),\n):\nif current_user.id != user_id:\nraise HTTPException(status_code=400, detail='Not enough permissions')\ndb_user = session.scalar(select(User).where(User.id == user_id))\nif db_user is None:\nraise HTTPException(status_code=404, detail='User not found')\nsession.delete(db_user)\nsession.commit()\nreturn {'detail': 'User deleted'}\n</code></pre>"},{"location":"06/#criando-um-router-para-auth","title":"Criando um router para Auth","text":"<p>No momento, temos rotas para <code>/</code> e <code>/token</code> ainda no arquivo <code>fast_zero/app.py</code>. Vamos dar um passo adiante e criar um router separado para lidar com a autentica\u00e7\u00e3o. Desta forma, conseguiremos manter nosso arquivo principal (<code>app.py</code>) mais limpo e focado em sua responsabilidade principal que \u00e9 iniciar nossa aplica\u00e7\u00e3o. </p> <p>O router para autentica\u00e7\u00e3o ser\u00e1 criado no arquivo <code>fast_zero/routers/auth.py</code>. Veja como fazer:</p> fast_zero/routers/auth.py<pre><code>from fastapi import APIRouter, Depends, HTTPException\nfrom fastapi.security import OAuth2PasswordRequestForm\nfrom sqlalchemy import select\nfrom sqlalchemy.orm import Session\nfrom fast_zero.database import get_session\nfrom fast_zero.models import User\nfrom fast_zero.schemas import Token\nfrom fast_zero.security import create_access_token, verify_password\nrouter = APIRouter()\n@router.post('/token', response_model=Token)\ndef login_for_access_token(\nform_data: OAuth2PasswordRequestForm = Depends(),\nsession: Session = Depends(get_session),\n):\nuser = session.scalar(select(User).where(User.email == form_data.username))\nif not user:\nraise HTTPException(\nstatus_code=400, detail='Incorrect email or password'\n)\nif not verify_password(form_data.password, user.password):\nraise HTTPException(\nstatus_code=400, detail='Incorrect email or password'\n)\naccess_token = create_access_token(data={'sub': user.email})\nreturn {'access_token': access_token, 'token_type': 'bearer'}\n</code></pre> <p>Neste bloco de c\u00f3digo, n\u00f3s criamos um novo router que lidar\u00e1 exclusivamente com a rota de obten\u00e7\u00e3o de token (<code>/token</code>). O endpoint <code>login_for_access_token</code> \u00e9 definido exatamente da mesma maneira que antes, mas agora como parte deste router de autentica\u00e7\u00e3o. </p> <p>Essa estrutura oferece algumas vantagens. Em primeiro lugar, nosso c\u00f3digo se torna mais organizado e mais f\u00e1cil de manter. Em segundo lugar, a separa\u00e7\u00e3o de responsabilidades (o chamado princ\u00edpio SoC) torna o c\u00f3digo mais f\u00e1cil de entender e testar. Por fim, nos permite escalar nosso aplicativo de maneira mais eficaz, pois podemos facilmente adicionar mais routers conforme o projeto cresce.</p>"},{"location":"06/#plugando-as-rotas-em-app","title":"Plugando as rotas em app","text":"<p>O FastAPI oferece uma maneira f\u00e1cil e direta de incluir routers em nossa aplica\u00e7\u00e3o principal. Isso nos permite organizar nossos endpoints de maneira eficiente e manter nosso arquivo <code>app.py</code> focado apenas em suas responsabilidades principais.</p> <p>Para incluir os routers em nossa aplica\u00e7\u00e3o principal, precisamos import\u00e1-los e usar a fun\u00e7\u00e3o <code>include_router()</code>. Aqui est\u00e1 como o nosso arquivo <code>app.py</code> fica depois de incluir os routers:</p> fast_zero/fast_zero/app.py<pre><code>from fastapi import FastAPI\nfrom fast_zero.routes import auth, users\napp = FastAPI()\napp.include_router(users.router)\napp.include_router(auth.router)\n@app.get('/')\ndef read_root():\nreturn {'message': 'Ol\u00e1 Mundo!'}\n</code></pre> <p>Como voc\u00ea pode ver, nosso arquivo <code>app.py</code> \u00e9 muito mais simples agora. Ele agora delega as rotas para os respectivos routers, mantendo o foco em iniciar nossa aplica\u00e7\u00e3o FastAPI.</p>"},{"location":"06/#executando-os-testes","title":"Executando os testes","text":"<p>Depois de refatorar nosso c\u00f3digo, \u00e9 crucial verificar se tudo ainda est\u00e1 funcionando como esperado. Para isso, executamos nossos testes novamente.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n# ...\ntests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED\ntests/test_app.py::test_create_user PASSED\ntests/test_app.py::test_read_users PASSED\ntests/test_app.py::test_read_users_with_users PASSED\ntests/test_app.py::test_update_user PASSED\ntests/test_app.py::test_delete_user PASSED\ntests/test_app.py::test_get_token PASSED\ntests/test_db.py::test_create_user PASSED\n</code></pre> <p>Como voc\u00ea pode ver, todos os testes passaram. Isso significa que as altera\u00e7\u00f5es que fizemos no nosso c\u00f3digo n\u00e3o afetaram o funcionamento do nosso aplicativo. O router manteve todos os endpoints nas mesmas rotas, garantindo a continuidade do comportamento esperado.</p> <p>Agora, para melhor alinhar nossos testes com a nova estrutura do nosso c\u00f3digo, devemos reorganizar os arquivos de teste de acordo. Ou seja, tamb\u00e9m devemos criar arquivos de teste espec\u00edficos para cada router, em vez de manter todos os testes no arquivo <code>tests/test_app.py</code>. Essa estrutura facilitar\u00e1 a manuten\u00e7\u00e3o e compreens\u00e3o dos testes \u00e0 medida que nossa aplica\u00e7\u00e3o cresce.</p>"},{"location":"06/#reestruturando-os-arquivos-de-testes","title":"Reestruturando os arquivos de testes","text":"<p>Agora que o nosso projeto foi reestruturado, \u00e9 importante manter a organiza\u00e7\u00e3o nos arquivos de teste tamb\u00e9m. Agora, temos 3 arquivos de teste diferentes: </p> <ul> <li><code>/tests/test_app.py</code>: Para testes relacionados ao aplicativo em geral</li> <li><code>/tests/test_auth.py</code>: Para testes relacionados \u00e0 autentica\u00e7\u00e3o e token</li> <li><code>/tests/test_users.py</code>: Para testes relacionados \u00e0s rotas de usu\u00e1rios</li> </ul> <p>Vamos adaptar os testes para se encaixarem nessa nova estrutura.</p>"},{"location":"06/#ajustando-os-testes-para-auth","title":"Ajustando os testes para Auth","text":"<p>Vamos come\u00e7ar criando o arquivo <code>/tests/test_auth.py</code>. Esse arquivo ser\u00e1 respons\u00e1vel por testar todas as funcionalidades relacionadas \u00e0 autentica\u00e7\u00e3o do usu\u00e1rio.</p> /tests/test_auth.py<pre><code>def test_get_token(client, user):\nresponse = client.post(\n'/token',\ndata={'username': user.email, 'password': user.clean_password},\n)\ntoken = response.json()\nassert response.status_code == 200\nassert 'access_token' in token\nassert 'token_type' in token\n</code></pre>"},{"location":"06/#ajustando-os-testes-para-user","title":"Ajustando os testes para User","text":"<p>Em seguida, vamos mover os testes relacionados ao usu\u00e1rio para o arquivo <code>/tests/test_users.py</code>.</p> /tests/test_users.py<pre><code>from fast_zero.schemas import UserPublic\ndef test_create_user(client):\nresponse = client.post(\n'/users/',\njson={\n'username': 'alice',\n'email': 'alice@example.com',\n'password': 'secret',\n},\n)\nassert response.status_code == 201\nassert response.json() == {\n'username': 'alice',\n'email': 'alice@example.com',\n'id': 1,\n}\ndef test_read_users(client):\nresponse = client.get('/users/')\nassert response.status_code == 200\nassert response.json() == {'users': []}\ndef test_read_users_with_users(client, user):\nuser_schema = UserPublic.model_validate(user).model_dump()\nresponse = client.get('/users/')\nassert response.json() == {'users': [user_schema]}\ndef test_update_user(client, user, token):\nresponse = client.put(\nf'/users/{user.id}',\nheaders={'Authorization': f'Bearer {token}'},\njson={\n'username': 'bob',\n'email': 'bob@example.com',\n'password': 'mynewpassword',\n},\n)\nassert response.status_code == 200\nassert response.json() == {\n'username': 'bob',\n'email': 'bob@example.com',\n'id': 1,\n}\ndef test_delete_user(client, user, token):\nresponse = client.delete(\nf'/users/{user.id}',\nheaders={'Authorization': f'Bearer {token}'},\n)\nassert response.status_code == 200\nassert response.json() == {'detail': 'User deleted'}\n</code></pre> <p>Essa organiza\u00e7\u00e3o facilita a manuten\u00e7\u00e3o dos testes, tornando-os mais claros e alinhados com a estrutura do nosso projeto.</p>"},{"location":"06/#executando-os-testes_1","title":"Executando os testes","text":"<p>Ap\u00f3s essa reestrutura\u00e7\u00e3o, \u00e9 importante garantir que tudo ainda est\u00e1 funcionando corretamente. Vamos executar os testes novamente para confirmar isso.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n# ...\ntests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED\ntests/test_auth.py::test_get_token PASSED\ntests/test_db.py::test_create_user PASSED\ntests/test_users.py::test_create_user PASSED\ntests/test_users.py::test_read_users PASSED\ntests/test_users.py::test_read_users_with_users PASSED\ntests/test_users.py::test_update_user PASSED\ntests/test_users.py::test_delete_user PASSED\n</code></pre> <p>Como podemos ver, todos os testes continuam passando com sucesso, mesmo ap\u00f3s terem sido movidos para arquivos diferentes. Isso \u00e9 uma confirma\u00e7\u00e3o de que nossa reestrutura\u00e7\u00e3o foi bem-sucedida e que nossa aplica\u00e7\u00e3o continua funcionando como esperado.</p>"},{"location":"06/#movendo-as-constantes-para-variaveis-de-ambiente","title":"Movendo as constantes para vari\u00e1veis de ambiente","text":"<p>Conforme mencionamos na aula sobre os 12 fatores, \u00e9 uma boa pr\u00e1tica manter as constantes que podem mudar dependendo do ambiente em vari\u00e1veis de ambiente. Isso torna o seu projeto mais seguro e modular, pois voc\u00ea pode alterar essas constantes sem ter que modificar o c\u00f3digo-fonte.</p> <p>Por exemplo, temos estas constantes em nosso m\u00f3dulo <code>security.py</code>:</p> <pre><code>SECRET_KEY = 'your-secret-key'  # Isso \u00e9 provis\u00f3rio, vamos ajustar!\nALGORITHM = 'HS256'\nACCESS_TOKEN_EXPIRE_MINUTES = 30\n</code></pre> <p>Estes valores n\u00e3o devem estar diretamente no c\u00f3digo-fonte, ent\u00e3o vamos mov\u00ea-los para nossas vari\u00e1veis de ambiente e represent\u00e1-los na nossa classe <code>Settings</code>.</p>"},{"location":"06/#adicionando-as-constantes-a-settings","title":"Adicionando as constantes a Settings","text":"<p>J\u00e1 temos uma classe ideal para fazer isso em <code>zero_app/settings.py</code>. Vamos alterar essa classe para incluir estas constantes.</p> zero_app/settings.py<pre><code>from pydantic_settings import BaseSettings, SettingsConfigDict\nclass Settings(BaseSettings):\nmodel_config = SettingsConfigDict(\nenv_file='.env', env_file_encoding='utf-8'\n)\nDATABASE_URL: str\nSECRET_KEY: str\nALGORITHM: str\nACCESS_TOKEN_EXPIRE_MINUTES: int\n</code></pre> <p>Agora, precisamos adicionar estes valores ao nosso arquivo <code>.env</code>.</p> .env<pre><code>DATABASE_URL=\"sqlite:///database.db\"\nSECRET_KEY=\"your-secret-key\"\nALGORITHM=\"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES=30\n</code></pre> <p>Com isso, podemos alterar o nosso c\u00f3digo em <code>zero_app/security.py</code> para ler as constantes a partir da classe <code>Settings</code>.</p>"},{"location":"06/#removendo-as-constantes-do-codigo","title":"Removendo as constantes do c\u00f3digo","text":"<p>Primeiramente, vamos carregar as configura\u00e7\u00f5es da classe <code>Settings</code> no in\u00edcio do m\u00f3dulo <code>security.py</code>.</p> zero_app/security.py<pre><code>from fast_zero.settings import Settings\nsettings = Settings()\n</code></pre> <p>Com isso, todos os lugares onde as constantes eram usadas devem ser substitu\u00eddos por <code>settings.CONSTANTE</code>. Por exemplo, na fun\u00e7\u00e3o <code>create_access_token</code>, vamos alterar para usar as constantes da classe <code>Settings</code>:</p> zero_app/security.py<pre><code>def create_access_token(data: dict):\nto_encode = data.copy()\nexpire = datetime.utcnow() + timedelta(\nminutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES\n)\nto_encode.update({'exp': expire})\nencoded_jwt = jwt.encode(\nto_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM\n)\nreturn encoded_jwt\n</code></pre> <p>Desta forma, eliminamos todas as constantes do c\u00f3digo-fonte e passamos a usar as configura\u00e7\u00f5es a partir da classe <code>Settings</code>. Isso torna nosso c\u00f3digo mais seguro, pois as constantes sens\u00edveis, como a chave secreta, est\u00e3o agora seguras em nosso arquivo <code>.env</code>, e nosso c\u00f3digo fica mais modular, pois podemos facilmente alterar estas constantes simplesmente mudando os valores no arquivo <code>.env</code>. Al\u00e9m disso, essa abordagem facilita o gerenciamento de diferentes ambientes (como desenvolvimento, teste e produ\u00e7\u00e3o) pois cada ambiente pode ter seu pr\u00f3prio arquivo <code>.env</code> com suas configura\u00e7\u00f5es espec\u00edficas.</p>"},{"location":"06/#testando-se-tudo-funciona","title":"Testando se tudo funciona","text":"<p>Depois de todas essas mudan\u00e7as, \u00e9 muito importante garantir que tudo ainda est\u00e1 funcionando corretamente. Para isso, vamos rodar todos os testes que temos at\u00e9 agora.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n# ...\ntests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED\ntests/test_auth.py::test_get_token PASSED\ntests/test_db.py::test_create_user PASSED\ntests/test_users.py::test_create_user PASSED\ntests/test_users.py::test_read_users PASSED\ntests/test_users.py::test_read_users_with_users PASSED\ntests/test_users.py::test_update_user PASSED\ntests/test_users.py::test_delete_user PASSED\n</code></pre> <p>Se tudo estiver certo, todos os testes devem passar. Lembre-se de que a refatora\u00e7\u00e3o n\u00e3o deve alterar a funcionalidade do nosso c\u00f3digo - apenas torn\u00e1-lo mais f\u00e1cil de ler e manter.</p>"},{"location":"06/#commit","title":"Commit","text":"<p>Para finalizar, vamos criar um commit para registrar todas as altera\u00e7\u00f5es que fizemos na nossa aplica\u00e7\u00e3o. Como essa \u00e9 uma grande mudan\u00e7a que envolve reestruturar a forma como lidamos com as rotas e mover as constantes para vari\u00e1veis de ambiente, podemos usar uma mensagem de commit descritiva que explique todas as principais altera\u00e7\u00f5es:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git add .\ngit commit -m \"Refatorando estrutura do projeto: Criado routers para Users e Auth; movido constantes para vari\u00e1veis de ambiente.\"\n</code></pre>"},{"location":"06/#conclusao","title":"Conclus\u00e3o","text":"<p>Nesta aula, vimos como refatorar a estrutura do nosso projeto FastAPI para torn\u00e1-lo mais manuten\u00edvel. Organizamos nosso c\u00f3digo em diferentes arquivos e usamos o sistema de roteadores do FastAPI para separar diferentes partes da nossa API. Tamb\u00e9m mudamos algumas constantes para o arquivo de configura\u00e7\u00e3o, tornando nosso c\u00f3digo mais seguro e flex\u00edvel. Finalmente, atualizamos nossos testes para refletir a nova estrutura do projeto.</p> <p>Refatorar \u00e9 um processo cont\u00ednuo - sempre h\u00e1 espa\u00e7o para melhorias. No entanto, com a estrutura que estabelecemos hoje, estamos em uma boa posi\u00e7\u00e3o para continuar a expandir nossa API no futuro.</p> <p>Na pr\u00f3xima aula, vamos explorar mais sobre autentica\u00e7\u00e3o e como gerenciar tokens de acesso e de atualiza\u00e7\u00e3o em nossa API FastAPI. Fique ligado!</p>"}]}